# Dragon Breath & Recharge Module
# Functions for handling dragon breath attacks, recharge mechanics, and map breath weapon overlays

using(
    mapl = "1d668d94-2807-47ca-b07c-e414b3342b5f"
)

# === RECHARGE MECHANICS ===

def parse_recharge(attack_desc):
    """
    Extract recharge information from attack description.
    Returns dict with 'min' value needed to recharge, or None if not a recharge ability.
    Examples: "Recharge 5-6" -> {'min': 5}, "Recharge 6" -> {'min': 6}
    """
    if not attack_desc:
        return None

    attack_lower = attack_desc.lower()

    # Check for recharge pattern
    if "recharge" not in attack_lower:
        return None

    # Extract the number(s) after "recharge"
    # Pattern: "recharge X-Y" or "recharge X"
    words = attack_lower.split()
    for i, word in enumerate(words):
        if "recharge" in word and i + 1 < len(words):
            next_word = words[i + 1].strip('():;,.')
            # Handle "5-6" format
            if '-' in next_word:
                min_val = next_word.split('-')[0]
                if min_val and min_val.isdigit():
                    return {'min': int(min_val)}
            # Handle single number "6"
            elif next_word.isdigit():
                return {'min': int(next_word)}

    return None


def attempt_recharge(recharge_min):
    """
    Attempt to recharge an ability. Rolls 1d6.
    Returns tuple: (success: bool, roll_result: str from vroll)
    """
    roll_result = vroll("1d6")
    roll_value = roll_result.total
    success = roll_value >= recharge_min

    return success, roll_result


def get_recharge_phrase(attack_name, recharged, roll_result, failed_attack_name=None):
    """
    Generate phrase text for recharge attempt.
    If recharged: shows success message
    If not recharged: shows failure and alternative attack used
    """
    roll_str = roll_result.result if typeof(roll_result) != "str" else roll_result

    if recharged:
        return f"**{attack_name}** recharged! [{roll_str}] :zap:"
    else:
        fail_msg = f"**{attack_name}** failed to recharge [{roll_str}]"
        if failed_attack_name:
            fail_msg += f" - using **{failed_attack_name}** instead"
        return fail_msg


def has_recharge_ability(monster):
    """
    Check if monster has any recharge abilities by checking for " Used" effect.
    Returns effect if found, None otherwise.
    """
    return monster.get_effect(" Used")


def get_recharge_attacks(monster):
    """
    Get all attacks with recharge from a monster.
    Returns list of dicts: [{'attack': attack_obj, 'name': str, 'recharge': {'min': int}}]
    """
    recharge_attacks = []

    for attack in monster.attacks:
        # Get attack description/automation text
        attack_text = get_attack_desc(attack)
        recharge_info = parse_recharge(attack_text)

        if recharge_info:
            recharge_attacks.append({
                'attack': attack,
                'name': attack.name,
                'recharge': recharge_info
            })

    return recharge_attacks


def get_attack_desc(attack):
    """
    Extract the full description text from an attack object.
    Checks both attack.raw structure and automation entries.
    """
    desc_parts = []

    # Try to access attack.raw - in Draconic, just check if it exists
    attack_raw = attack.raw if attack else None

    if attack_raw:
        # Get verb (like "Melee Weapon Attack")
        if 'verb' in attack_raw:
            desc_parts.append(attack_raw['verb'])

        # Get details
        if 'details' in attack_raw:
            desc_parts.append(attack_raw['details'])

        # Check automation for text entries
        if 'automation' in attack_raw:
            for entry in attack_raw['automation']:
                if typeof(entry) == 'SafeDict' and entry.get('type') == 'text':
                    if 'text' in entry:
                        desc_parts.append(entry['text'])

    return ' '.join(desc_parts)


# === BREATH WEAPON DETECTION ===

def is_breath_weapon(attack_name):
    """
    Check if an attack is a breath weapon based on name.
    """
    name_lower = attack_name.lower()
    breath_keywords = ['breath', 'exhalation']

    return any(keyword in name_lower for keyword in breath_keywords)


def get_breath_type(attack_text):
    """
    Detect breath weapon damage type from attack text.
    Returns dict with damage type and suggested color for overlay.
    """
    text_lower = attack_text.lower()

    breath_types = {
        'fire': {'color': 'r', 'name': 'Fire'},
        'cold': {'color': 'b', 'name': 'Cold'},
        'lightning': {'color': 'y', 'name': 'Lightning'},
        'acid': {'color': 'g', 'name': 'Acid'},
        'poison': {'color': 'g', 'name': 'Poison'},
        'necrotic': {'color': 'p', 'name': 'Necrotic'},
        'radiant': {'color': 'y', 'name': 'Radiant'},
    }

    for damage_type, info in breath_types.items():
        if damage_type in text_lower:
            return info

    # Default to red if unknown
    return {'color': 'r', 'name': 'Unknown'}


def parse_breath_shape(attack_text):
    """
    Parse breath weapon shape from attack description.
    Returns dict: {'shape': 'cone'|'line', 'size': int, 'width': int}
    """
    text_lower = attack_text.lower()
    shape_info = {}

    # Check for cone
    if 'cone' in text_lower:
        shape_info['shape'] = 'cone'
        # Extract size (e.g., "30-foot cone" or "30 ft. cone")
        words = text_lower.replace('-', ' ').split()
        for i, word in enumerate(words):
            if 'cone' in word and i > 0:
                # Look backwards for a number
                for j in range(i-1, max(i-3, -1), -1):
                    num = ''.join(c for c in words[j] if c.isdigit())
                    if num:
                        shape_info['size'] = int(num)
                        break

    # Check for line
    elif 'line' in text_lower:
        shape_info['shape'] = 'line'
        words = text_lower.replace('-', ' ').split()
        for i, word in enumerate(words):
            if 'line' in word and i > 0:
                # Look for length
                for j in range(i-1, max(i-4, -1), -1):
                    num = ''.join(c for c in words[j] if c.isdigit())
                    if num:
                        shape_info['size'] = int(num)
                        # Look for width (usually "X-foot long and Y feet wide")
                        for k in range(i, min(i+10, len(words))):
                            if 'wide' in words[k] and k > 0:
                                width_num = ''.join(c for c in words[k-1] if c.isdigit())
                                if width_num:
                                    shape_info['width'] = int(width_num)
                        break

        # Default width if not found
        if 'width' not in shape_info:
            shape_info['width'] = 5

    # Default to 30-foot cone if no shape detected
    if 'shape' not in shape_info:
        shape_info = {'shape': 'cone', 'size': 30}

    return shape_info


def create_breath_overlay(monster_loc, target_loc, breath_shape, breath_type):
    """
    Create overlay string for breath weapon.
    Format: {shape_code}{size}{width}{color}{loc}{eloc}

    Args:
        monster_loc: Monster's location (e.g., "B5")
        target_loc: Target/aim location (e.g., "D7")
        breath_shape: Dict from parse_breath_shape()
        breath_type: Dict from get_breath_type()

    Returns:
        Overlay string (e.g., "t30rB5D7" for 30ft red cone from B5 to D7)
    """
    shape = breath_shape.get('shape', 'cone')
    size = breath_shape.get('size', 30)
    color = breath_type.get('color', 'r')

    if shape == 'cone':
        # Cone format: t{size}{color}{start_loc}{end_loc}
        return f"t{size}{color}{monster_loc}{target_loc}"

    elif shape == 'line':
        # Line format: l{size},{width}{color}{start_loc}{end_loc}
        width = breath_shape.get('width', 5)
        return f"l{size},{width}{color}{monster_loc}{target_loc}"

    # Fallback to cone
    return f"t{size}{color}{monster_loc}{target_loc}"


def get_breath_attacks(monster):
    """
    Get all breath weapon attacks from a monster.
    Returns list of dicts with attack info and breath details.
    """
    breath_attacks = []

    for attack in monster.attacks:
        if is_breath_weapon(attack.name):
            attack_text = get_attack_desc(attack)
            breath_shape = parse_breath_shape(attack_text)
            breath_type = get_breath_type(attack_text)
            recharge_info = parse_recharge(attack_text)

            breath_attacks.append({
                'attack': attack,
                'name': attack.name,
                'shape': breath_shape,
                'type': breath_type,
                'recharge': recharge_info,
                'text': attack_text
            })

    return breath_attacks


# === HELPER FUNCTIONS FOR TARGETING ===
#
# ALGORITHMS USED (Established game dev techniques):
# 1. Vector Projection Method (dot/cross product)
#    - Used for cone and line targeting
#    - Standard in game development (Unity, Unreal, roguelikes)
#    - Sources: Wolfire Games, Unity tutorials, GameDev.net
#
# 2. D&D 5e Cone Rules (DMG p.251)
#    - "Cone's width at given point = distance from origin"
#    - At 30ft distance, cone is 30ft wide
#
# 3. Optimal Placement
#    - Brute force testing of potential aim points
#    - Tests all target locations + adjacent squares
#    - Could be optimized with shadowcasting (MRPAS/recursive)
#    - Current approach: O(targets * aim_options) - acceptable for combat
#
# Alternative approaches considered:
# - Bresenham's algorithm for lines (available via mapl.get_line_area)
# - Shadowcasting FOV algorithms (MRPAS, symmetric shadowcasting)
# - These are more complex but provide better obstacle handling

def is_in_cone(origin_loc, aim_loc, target_loc, cone_size_ft):
    """
    Check if target is within a cone AoE using proper vector math.
    Cone emanates from origin towards aim point.

    D&D 5e cone rules:
    - Cone starts at origin point
    - Spreads out in direction of aim
    - Width at end equals length (e.g., 30ft cone is 30ft wide at 30ft distance)
    """
    # Convert locations to coordinates
    ox, oy = mapl.loc_to_coords(origin_loc)
    ax, ay = mapl.loc_to_coords(aim_loc)
    tx, ty = mapl.loc_to_coords(target_loc)

    # Vector from origin to aim (direction of cone)
    aim_dx = ax - ox
    aim_dy = ay - oy
    aim_length = (aim_dx * aim_dx + aim_dy * aim_dy) ** 0.5

    if aim_length == 0:
        return False

    # Normalize aim vector
    aim_nx = aim_dx / aim_length
    aim_ny = aim_dy / aim_length

    # Vector from origin to target
    target_dx = tx - ox
    target_dy = ty - oy

    # Distance from origin to target (in squares)
    target_dist_squares = (target_dx * target_dx + target_dy * target_dy) ** 0.5
    target_dist_ft = target_dist_squares * 5

    # Check if target is beyond cone range
    if target_dist_ft > cone_size_ft:
        return False

    # Dot product to find projection of target onto aim direction
    dot_product = target_dx * aim_nx + target_dy * aim_ny

    # Target should be in front of origin (positive dot product)
    if dot_product <= 0:
        return False

    # Cross product to find perpendicular distance from aim line
    # In 2D: cross = ax*by - ay*bx
    cross_product = abs(target_dx * aim_ny - target_dy * aim_nx)
    perp_dist_squares = cross_product

    # Cone width at target's distance
    # D&D 5e: total width at distance d = d (e.g., 30ft cone is 30ft wide at 30ft)
    # Therefore radius (perpendicular distance from centerline) = d/2
    # At distance d squares, allowed radius = d/2 squares
    allowed_radius_squares = dot_product / 2

    # Check if target is within cone radius at its distance
    return perp_dist_squares <= allowed_radius_squares


def find_best_cone_aim(origin_loc, targets, cone_size_ft, c_obj):
    """
    Find best cone aim using proper cone collision detection.
    Tests aiming at each target (max iterations = # of targets).
    Uses vector math (dot/cross product) for accurate cone AoE.
    """
    if not targets:
        return None, []

    # Get target locations
    target_locations = {}
    for tname in targets:
        target = c_obj.get_combatant(tname)
        if target:
            tmap = mapl.parse_note(target.note)
            tloc = tmap.get('location')
            if tloc:
                target_locations[tname] = tloc

    if not target_locations:
        return None, []

    # Try aiming at each target location (limited iterations)
    best_aim = None
    best_hits = []
    max_hit_count = 0

    for tname, tloc in target_locations.items():
        # Count how many targets are hit when aiming at this location
        hits = []
        for check_name, check_loc in target_locations.items():
            if is_in_cone(origin_loc, tloc, check_loc, cone_size_ft):
                hits.append(check_name)

        # Update best
        if len(hits) > max_hit_count:
            max_hit_count = len(hits)
            best_aim = tloc
            best_hits = hits

    return best_aim, best_hits


def find_best_line_aim(origin_loc, targets, line_length_ft, line_width_ft, c_obj):
    """
    Find best line aim using influence mapping approach.
    Tests aiming at each target (max iterations = # of targets).
    Uses MAPL's get_line_area with Bresenham's algorithm.
    """
    if not targets:
        return None, []

    # Get target coords once
    target_coords = {}
    for tname in targets:
        target = c_obj.get_combatant(tname)
        if target:
            tmap = mapl.parse_note(target.note)
            tloc = tmap.get('location')
            if tloc:
                tx, ty = mapl.loc_to_coords(tloc)
                target_coords[tname] = (tx, ty)

    if not target_coords:
        return None, []

    # Convert origin and calculate max distance
    ox, oy = mapl.loc_to_coords(origin_loc)
    max_dist = line_length_ft / 5

    # Try aiming at each target location (limited iterations)
    best_aim = None
    best_hits = []
    max_hit_count = 0

    for tname in target_coords:
        tx, ty = target_coords[tname]

        # Calculate line endpoint in direction of target
        dx = tx - ox
        dy = ty - oy
        dist = (dx * dx + dy * dy) ** 0.5

        if dist == 0:
            continue

        # Extend to max line length
        scale = max_dist / dist
        end_x = ox + dx * scale
        end_y = oy + dy * scale

        # Get line area using MAPL's Bresenham algorithm
        line_area_coords = mapl.get_line_area((ox, oy), (end_x, end_y), line_width_ft / 5)
        line_area_set = set(line_area_coords)

        # Count hits
        hits = []
        for check_name, (cx, cy) in target_coords.items():
            if (cx, cy) in line_area_set:
                hits.append(check_name)

        # Update best
        if len(hits) > max_hit_count:
            max_hit_count = len(hits)
            best_aim = mapl.coords_to_loc((tx, ty))
            best_hits = hits

    return best_aim, best_hits


def find_breath_targets(monster_loc, target_loc, breath_shape, all_targets):
    """
    Find all targets caught in breath weapon AoE.

    Args:
        monster_loc: Monster's location string
        target_loc: Aimed location string
        breath_shape: Dict from parse_breath_shape()
        all_targets: List of target names to check

    Returns:
        List of target names in the AoE
    """
    affected = []

    # Convert breath shape to aoe_attack format for compatibility
    aoe_attack = {
        'shape': breath_shape['shape'],
        'size': breath_shape['size']
    }

    if breath_shape['shape'] == 'line':
        aoe_attack['width'] = breath_shape.get('width', 5)

    # Use existing is_in_aoe logic
    for target_name in all_targets:
        # This would use the existing targeting logic from auto.alias
        # For now, return placeholder - integrate with actual targeting in auto.alias
        pass

    return affected


# === INTEGRATION HELPERS ===

def format_breath_attack_phrase(attack_name, breath_type, targets_hit, recharge_msg=""):
    """
    Format the attack phrase for breath weapons.
    Combines recharge status and attack execution.
    """
    breath_emoji = {
        'Fire': ':fire:',
        'Cold': ':snowflake:',
        'Lightning': ':zap:',
        'Acid': ':test_tube:',
        'Poison': ':skull:',
        'Necrotic': ':skull_crossbones:',
        'Radiant': ':sunny:'
    }

    emoji = breath_emoji.get(breath_type.get('name', 'Unknown'), ':dragon:')
    phrase_parts = []

    if recharge_msg:
        phrase_parts.append(recharge_msg)

    phrase_parts.append(f"{emoji} **{attack_name}** {emoji}")

    if targets_hit > 0:
        phrase_parts.append(f"({targets_hit} target{'s' if targets_hit != 1 else ''} caught in blast)")

    return '\n'.join(phrase_parts)


