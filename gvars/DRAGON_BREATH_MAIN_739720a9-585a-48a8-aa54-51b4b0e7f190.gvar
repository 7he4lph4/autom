# Dragon Breath & Recharge Module
# Functions for handling dragon breath attacks, recharge mechanics, and map breath weapon overlays

using(
    mapl = "1d668d94-2807-47ca-b07c-e414b3342b5f"
)

# === RECHARGE MECHANICS ===

def parse_recharge(attack_raw):
    """
    Extract recharge information from attack.raw automation structure.
    Returns dict with 'min' value needed to recharge and 'dice' to roll, or None if not a recharge ability.
    Example: {'min': 5, 'dice': '1d6'}
    """
    if not attack_raw or typeof(attack_raw) != 'SafeDict':
        return None

    # Look through automation for buttons with recharge
    automation = attack_raw.get('automation', [])
    if not automation:
        return None

    for auto_entry in automation:
        if typeof(auto_entry) != 'SafeDict':
            continue

        # Check for target with effects that have buttons
        if auto_entry.get('type') == 'target':
            effects = auto_entry.get('effects', [])
            for effect in effects:
                if typeof(effect) != 'SafeDict':
                    continue

                buttons = effect.get('buttons', [])
                for button in buttons:
                    if typeof(button) != 'SafeDict':
                        continue

                    # Check if this is a recharge button
                    label = button.get('label', '').lower()
                    if 'recharge' not in label:
                        continue

                    # Parse the button automation
                    button_auto = button.get('automation', [])
                    recharge_dice = '1d6'  # Default
                    recharge_min = None

                    for btn_entry in button_auto:
                        if typeof(btn_entry) != 'SafeDict':
                            continue

                        # Get dice roll
                        if btn_entry.get('type') == 'roll' and btn_entry.get('name') == 'recharge':
                            recharge_dice = btn_entry.get('dice', '1d6')

                        # Get condition with minimum value
                        if btn_entry.get('type') == 'condition':
                            condition = btn_entry.get('condition', '')
                            # Parse "int(recharge) >= 5" or similar
                            if '>=' in condition:
                                parts = condition.split('>=')
                                if len(parts) == 2:
                                    min_str = parts[1].strip()
                                    # Remove any trailing characters
                                    min_str = ''.join([c for c in min_str if c.isdigit()])
                                    if min_str:
                                        recharge_min = int(min_str)

                    if recharge_min is not None:
                        return {'min': recharge_min, 'dice': recharge_dice}

    return None


def attempt_recharge(recharge_min, dice='1d6'):
    """
    Attempt to recharge an ability. Rolls specified dice (default 1d6).
    Returns tuple: (success: bool, roll_result: str from vroll)
    """
    roll_result = vroll(dice)
    roll_value = roll_result.total
    success = roll_value >= recharge_min

    return success, roll_result


def get_recharge_phrase(attack_name, recharged, roll_result, failed_attack_name=None):
    """
    Generate phrase text for recharge attempt.
    If recharged: shows success message
    If not recharged: shows failure and alternative attack used
    """
    roll_str = roll_result.result if typeof(roll_result) != "str" else roll_result

    if recharged:
        return f"**{attack_name}** recharged! [{roll_str}] :zap:"
    else:
        fail_msg = f"**{attack_name}** failed to recharge [{roll_str}]"
        if failed_attack_name:
            fail_msg += f" - using **{failed_attack_name}** instead"
        return fail_msg


def has_recharge_ability(monster):
    """
    Check if monster has any recharge abilities by checking for " Used" effect.
    Returns effect if found, None otherwise.
    """
    return monster.get_effect(" Used")


def get_recharge_attacks(monster):
    """
    Get all attacks with recharge from a monster.
    Returns list of dicts: [{'attack': attack_obj, 'name': str, 'recharge': {'min': int, 'dice': str}}]
    """
    recharge_attacks = []

    for attack in monster.attacks:
        # Get attack.raw and parse recharge from automation structure
        attack_raw = attack.raw if attack else None
        recharge_info = parse_recharge(attack_raw)

        if recharge_info:
            recharge_attacks.append({
                'attack': attack,
                'name': attack.name,
                'recharge': recharge_info
            })

    return recharge_attacks


def get_attack_desc(attack):
    """
    Extract the full description text from an attack object.
    Checks both attack.raw structure and automation entries.
    """
    desc_parts = []

    # Try to access attack.raw - in Draconic, just check if it exists
    attack_raw = attack.raw if attack else None

    if attack_raw:
        # Get verb (like "Melee Weapon Attack")
        if 'verb' in attack_raw:
            desc_parts.append(attack_raw['verb'])

        # Get details
        if 'details' in attack_raw:
            desc_parts.append(attack_raw['details'])

        # Check automation for text entries
        if 'automation' in attack_raw:
            for entry in attack_raw['automation']:
                if typeof(entry) == 'SafeDict' and entry.get('type') == 'text':
                    if 'text' in entry:
                        desc_parts.append(entry['text'])

    return ' '.join(desc_parts)


# === BREATH WEAPON DETECTION ===

def is_breath_weapon(attack_name):
    """
    Check if an attack is a breath weapon based on name.
    """
    name_lower = attack_name.lower()
    breath_keywords = ['breath', 'exhalation']

    return any(keyword in name_lower for keyword in breath_keywords)


def get_breath_type(attack_text):
    """
    Detect breath weapon damage type from attack text.
    Returns dict with damage type and suggested color for overlay.
    """
    text_lower = attack_text.lower()

    breath_types = {
        'fire': {'color': 'r', 'name': 'Fire'},
        'cold': {'color': 'b', 'name': 'Cold'},
        'lightning': {'color': 'y', 'name': 'Lightning'},
        'acid': {'color': 'g', 'name': 'Acid'},
        'poison': {'color': 'g', 'name': 'Poison'},
        'necrotic': {'color': 'p', 'name': 'Necrotic'},
        'radiant': {'color': 'y', 'name': 'Radiant'},
    }

    for damage_type, info in breath_types.items():
        if damage_type in text_lower:
            return info

    # Default to red if unknown
    return {'color': 'r', 'name': 'Unknown'}


def parse_breath_shape(attack_text):
    """
    Parse breath weapon shape from attack description.
    Returns dict: {'shape': 'cone'|'line', 'size': int, 'width': int}
    """
    text_lower = attack_text.lower()
    shape_info = {}

    # Check for cone
    if 'cone' in text_lower:
        shape_info['shape'] = 'cone'
        # Extract size (e.g., "30-foot cone" or "30 ft. cone")
        words = text_lower.replace('-', ' ').split()
        for i, word in enumerate(words):
            if 'cone' in word and i > 0:
                # Look backwards for a number
                for j in range(i-1, max(i-3, -1), -1):
                    num = ''.join(c for c in words[j] if c.isdigit())
                    if num:
                        shape_info['size'] = int(num)
                        break

    # Check for line
    elif 'line' in text_lower:
        shape_info['shape'] = 'line'
        words = text_lower.replace('-', ' ').split()
        for i, word in enumerate(words):
            if 'line' in word and i > 0:
                # Look for length
                for j in range(i-1, max(i-4, -1), -1):
                    num = ''.join(c for c in words[j] if c.isdigit())
                    if num:
                        shape_info['size'] = int(num)
                        # Look for width (usually "X-foot long and Y feet wide")
                        for k in range(i, min(i+10, len(words))):
                            if 'wide' in words[k] and k > 0:
                                width_num = ''.join(c for c in words[k-1] if c.isdigit())
                                if width_num:
                                    shape_info['width'] = int(width_num)
                        break

        # Default width if not found
        if 'width' not in shape_info:
            shape_info['width'] = 5

    # Default to 30-foot cone if no shape detected
    if 'shape' not in shape_info:
        shape_info = {'shape': 'cone', 'size': 30}

    return shape_info


def create_breath_overlay(monster_loc, target_loc, breath_shape, breath_type):
    """
    Create overlay string for breath weapon.
    Format: {shape_code}{size}{width}{color}{loc}{eloc}

    Args:
        monster_loc: Monster's location (e.g., "B5")
        target_loc: Target/aim location (e.g., "D7")
        breath_shape: Dict from parse_breath_shape()
        breath_type: Dict from get_breath_type()

    Returns:
        Overlay string (e.g., "t30rB5D7" for 30ft red cone from B5 to D7)
    """
    shape = breath_shape.get('shape', 'cone')
    size = breath_shape.get('size', 30)
    color = breath_type.get('color', 'r')

    if shape == 'cone':
        # Cone format: t{size}{color}{start_loc}{end_loc}
        return f"t{size}{color}{monster_loc}{target_loc}"

    elif shape == 'line':
        # Line format: l{size},{width}{color}{start_loc}{end_loc}
        width = breath_shape.get('width', 5)
        return f"l{size},{width}{color}{monster_loc}{target_loc}"

    # Fallback to cone
    return f"t{size}{color}{monster_loc}{target_loc}"


def get_breath_attacks(monster):
    """
    Get all breath weapon attacks from a monster.
    Returns list of dicts with attack info and breath details.
    """
    breath_attacks = []

    for attack in monster.attacks:
        if is_breath_weapon(attack.name):
            attack_text = get_attack_desc(attack)
            breath_shape = parse_breath_shape(attack_text)
            breath_type = get_breath_type(attack_text)
            recharge_info = parse_recharge(attack_text)

            breath_attacks.append({
                'attack': attack,
                'name': attack.name,
                'shape': breath_shape,
                'type': breath_type,
                'recharge': recharge_info,
                'text': attack_text
            })

    return breath_attacks


# === HELPER FUNCTIONS FOR TARGETING ===
#
# ALGORITHMS USED (Established game dev techniques):
# 1. Vector Projection Method (dot/cross product)
#    - Used for cone and line targeting
#    - Standard in game development (Unity, Unreal, roguelikes)
#    - Sources: Wolfire Games, Unity tutorials, GameDev.net
#
# 2. D&D 5e Cone Rules (DMG p.251)
#    - "Cone's width at given point = distance from origin"
#    - At 30ft distance, cone is 30ft wide
#
# 3. Optimal Placement
#    - Brute force testing of potential aim points
#    - Tests all target locations + adjacent squares
#    - Could be optimized with shadowcasting (MRPAS/recursive)
#    - Current approach: O(targets * aim_options) - acceptable for combat
#
# Alternative approaches considered:
# - Bresenham's algorithm for lines (available via mapl.get_line_area)
# - Shadowcasting FOV algorithms (MRPAS, symmetric shadowcasting)
# - These are more complex but provide better obstacle handling

def is_in_cone(origin_loc, aim_loc, target_loc, cone_size_ft):
    """
    Check if target is within a cone AoE using proper vector math.
    Cone emanates from origin towards aim point.

    D&D 5e cone rules:
    - Cone starts at origin point
    - Spreads out in direction of aim
    - Width at end equals length (e.g., 30ft cone is 30ft wide at 30ft distance)
    """
    # Convert locations to coordinates
    ox, oy = mapl.loc_to_coords(origin_loc)
    ax, ay = mapl.loc_to_coords(aim_loc)
    tx, ty = mapl.loc_to_coords(target_loc)

    # Vector from origin to aim (direction of cone)
    aim_dx = ax - ox
    aim_dy = ay - oy
    aim_length = (aim_dx * aim_dx + aim_dy * aim_dy) ** 0.5

    if aim_length == 0:
        return False

    # Normalize aim vector
    aim_nx = aim_dx / aim_length
    aim_ny = aim_dy / aim_length

    # Vector from origin to target
    target_dx = tx - ox
    target_dy = ty - oy

    # Distance from origin to target (in squares)
    target_dist_squares = (target_dx * target_dx + target_dy * target_dy) ** 0.5
    target_dist_ft = target_dist_squares * 5

    # Check if target is beyond cone range
    if target_dist_ft > cone_size_ft:
        return False

    # Dot product to find projection of target onto aim direction
    dot_product = target_dx * aim_nx + target_dy * aim_ny

    # Target should be in front of origin (positive dot product)
    if dot_product <= 0:
        return False

    # Cross product to find perpendicular distance from aim line
    # In 2D: cross = ax*by - ay*bx
    cross_product = abs(target_dx * aim_ny - target_dy * aim_nx)
    perp_dist_squares = cross_product

    # Cone width at target's distance
    # D&D 5e: total width at distance d = d (e.g., 30ft cone is 30ft wide at 30ft)
    # Therefore radius (perpendicular distance from centerline) = d/2
    # At distance d squares, allowed radius = d/2 squares
    allowed_radius_squares = dot_product / 2

    # Check if target is within cone radius at its distance
    return perp_dist_squares <= allowed_radius_squares


def score_aoe_targets(targets_hit, caster_team, ally_penalty, c_obj, teams):
    """
    Universal AoE scoring function.
    Returns: (score, enemies, allies, enemy_names_only)

    Args:
        targets_hit: List of target names in AoE
        caster_team: Caster's team number
        ally_penalty: -1 for circles, -3 for cone/line
        c_obj: Combat object
        teams: Full teams dict
    """
    enemies = []
    allies = []

    for target_name in targets_hit:
        target = c_obj.get_combatant(target_name)
        if not target:
            continue

        # Determine target's team
        target_team = None
        for team_num, members in teams.items():
            if target_name in members:
                target_team = team_num
                break

        if target_team == caster_team:
            allies.append(target_name)
        else:
            enemies.append(target_name)

    score = (len(enemies) * 2) + (len(allies) * ally_penalty)

    return score, enemies, allies, enemies


def find_best_cone_aim(origin_loc, all_targets, cone_size_ft, c_obj, caster_team, teams):
    """
    Find best cone aim using proper cone collision detection with team-aware scoring.
    Tests aiming at each target (max iterations = # of targets).
    Uses vector math (dot/cross product) for accurate cone AoE.

    Args:
        origin_loc: Caster's location
        all_targets: ALL combatant names (enemies + allies)
        cone_size_ft: Cone size in feet
        c_obj: Combat object
        caster_team: Caster's team number
        teams: Full teams dict

    Returns:
        (best_aim, best_hits_all, best_hits_enemies_only)
    """
    if not all_targets:
        return None, [], []

    # Get ALL target locations (enemies + allies)
    target_locations = {}
    for tname in all_targets:
        target = c_obj.get_combatant(tname)
        if target:
            tmap = mapl.parse_note(target.note)
            tloc = tmap.get('location')
            if tloc:
                target_locations[tname] = tloc

    if not target_locations:
        return None, [], []

    # Try aiming at each target location
    best_aim = None
    best_hits_all = []
    best_hits_enemies_only = []
    best_score = -999

    for tname, tloc in target_locations.items():
        # Find all hits when aiming at this location
        hits = []
        for check_name, check_loc in target_locations.items():
            if is_in_cone(origin_loc, tloc, check_loc, cone_size_ft):
                hits.append(check_name)

        # Score this aim with team awareness
        score, enemies, allies, enemy_names = score_aoe_targets(hits, caster_team, -3, c_obj, teams)

        # Early exit optimization: 3+ enemies, no allies = perfect
        if score >= 6 and len(allies) == 0:
            return tloc, hits, enemy_names

        # Update best aim
        if score > best_score:
            best_score = score
            best_aim = tloc
            best_hits_all = hits
            best_hits_enemies_only = enemy_names

    return best_aim, best_hits_all, best_hits_enemies_only


def find_best_line_aim(origin_loc, all_targets, line_length_ft, line_width_ft, c_obj, caster_team, teams):
    """
    Find best line aim using influence mapping approach with team-aware scoring.
    Tests aiming at each target (max iterations = # of targets).
    Uses MAPL's get_line_area with Bresenham's algorithm.

    Args:
        origin_loc: Caster's location
        all_targets: ALL combatant names (enemies + allies)
        line_length_ft: Line length in feet
        line_width_ft: Line width in feet
        c_obj: Combat object
        caster_team: Caster's team number
        teams: Full teams dict

    Returns:
        (best_aim, best_hits_all, best_hits_enemies_only)
    """
    if not all_targets:
        return None, [], []

    # Get ALL target coords (enemies + allies)
    target_coords = {}
    for tname in all_targets:
        target = c_obj.get_combatant(tname)
        if target:
            tmap = mapl.parse_note(target.note)
            tloc = tmap.get('location')
            if tloc:
                tx, ty = mapl.loc_to_coords(tloc)
                target_coords[tname] = (tx, ty)

    if not target_coords:
        return None, [], []

    # Convert origin and calculate max distance
    ox, oy = mapl.loc_to_coords(origin_loc)
    max_dist = line_length_ft / 5

    # Try aiming at each target location
    best_aim = None
    best_hits_all = []
    best_hits_enemies_only = []
    best_score = -999

    for tname in target_coords:
        tx, ty = target_coords[tname]

        # Calculate line endpoint in direction of target
        dx = tx - ox
        dy = ty - oy
        dist = (dx * dx + dy * dy) ** 0.5

        if dist == 0:
            continue

        # Extend to max line length
        scale = max_dist / dist
        end_x = ox + dx * scale
        end_y = oy + dy * scale

        # Get line area using MAPL's Bresenham algorithm
        line_area_coords = mapl.get_line_area((ox, oy), (end_x, end_y), line_width_ft / 5)
        line_area_set = set(line_area_coords)

        # Find all hits
        hits = []
        for check_name, (cx, cy) in target_coords.items():
            if (cx, cy) in line_area_set:
                hits.append(check_name)

        # Score this aim with team awareness
        score, enemies, allies, enemy_names = score_aoe_targets(hits, caster_team, -3, c_obj, teams)

        # Early exit optimization: 3+ enemies, no allies = perfect
        if score >= 6 and len(allies) == 0:
            return mapl.coords_to_loc((tx, ty)), hits, enemy_names

        # Update best aim
        if score > best_score:
            best_score = score
            best_aim = mapl.coords_to_loc((tx, ty))
            best_hits_all = hits
            best_hits_enemies_only = enemy_names

    return best_aim, best_hits_all, best_hits_enemies_only


def find_breath_targets(monster_loc, target_loc, breath_shape, all_targets):
    """
    Find all targets caught in breath weapon AoE.

    Args:
        monster_loc: Monster's location string
        target_loc: Aimed location string
        breath_shape: Dict from parse_breath_shape()
        all_targets: List of target names to check

    Returns:
        List of target names in the AoE
    """
    affected = []

    # Convert breath shape to aoe_attack format for compatibility
    aoe_attack = {
        'shape': breath_shape['shape'],
        'size': breath_shape['size']
    }

    if breath_shape['shape'] == 'line':
        aoe_attack['width'] = breath_shape.get('width', 5)

    # Use existing is_in_aoe logic
    for target_name in all_targets:
        # This would use the existing targeting logic from auto.alias
        # For now, return placeholder - integrate with actual targeting in auto.alias
        pass

    return affected


# === INTEGRATION HELPERS ===

def format_breath_attack_phrase(attack_name, breath_type, targets_hit, recharge_msg=""):
    """
    Format the attack phrase for breath weapons.
    Combines recharge status and attack execution.
    """
    breath_emoji = {
        'Fire': ':fire:',
        'Cold': ':snowflake:',
        'Lightning': ':zap:',
        'Acid': ':test_tube:',
        'Poison': ':skull:',
        'Necrotic': ':skull_crossbones:',
        'Radiant': ':sunny:'
    }

    emoji = breath_emoji.get(breath_type.get('name', 'Unknown'), ':dragon:')
    phrase_parts = []

    if recharge_msg:
        phrase_parts.append(recharge_msg)

    phrase_parts.append(f"{emoji} **{attack_name}** {emoji}")

    if targets_hit > 0:
        phrase_parts.append(f"({targets_hit} target{'s' if targets_hit != 1 else ''} caught in blast)")

    return '\n'.join(phrase_parts)


