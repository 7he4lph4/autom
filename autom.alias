<drac2>
#auto
pref, al = ctx.prefix, ctx.alias
cmd = pref+al
null, nl, comma = '', '\n', ','
args = argparse(&ARGS&)

cname_list, monst_name_list, command_list, combatant_mismatch = [],[],[],[]
multiattack, spell_viable, counter = False, False, 0

raw_inp = "&*&"
inp = "&*&".lower().replace('"', '')
inp1 = "&1&"
inp2 = "&2&"
inp3 = "&3&"

using(
    autolib="ec14bc6e-81e4-4df7-86e9-5d64ed2fa9b7",
    core="49f5f503-1c00-4f24-ba43-92e65c2c2fb6",
    presets = "c14e4526-4acb-4964-8ba9-f6861617ffdf",
    mapl = "51af2e97-64e3-444a-994c-61c45c3f0994"
)

help_text = f"""How to use `{cmd}`:

- Start combat initiative with `{pref}i begin`, and add all the necessary players and monsters
    - *Pro Tip*: use the [Encounter Generator](https://avrae.io/dashboard/workshop/654fbc27ac7cd2bc90723133/) alias to quickly setup a balanced encounter for any party
- Once all monsters and players are added, use `{cmd}` to auto-magically add the *Map* combatant
- Use `{cmd} map list` to see all preset maps
- Use `{cmd} map <map name>` to load one of the preset maps
- Or, simply use `{cmd}` again to randomly pick one of the preset maps
    - (ideally you can keep spamming `{cmd}` after adding all players and monsters to combat initiative)
- Use `{cmd}` to automate all monsters until the next player in combat initiative

*Note*: If you'd like to keep using the old alias without maps support, you can use:
`{pref}autol`
(`l` stands for legacy)

This alias relies on the OTFBM backend service for map generation. They have server costs to cover, so please consider supporting their work through their [Patreon page](https://www.patreon.com/otfbm) if you're able

You can also support the development of this alias on [Ko-fi](https://ko-fi.com/hedy4u)!
"""

help_title = f'{name} needs help breathing life into these monsters!'
title = help_title
desc_text = help_text
footer = f'{cmd} help | made by @alpha983'

command = f"""multiline{nl}"""

c = combat()

if not c or inp == 'help' or inp == '?':
    title = f'{cmd} works best when used with a combat initiative full of player characters and monsters!'
    desc = 'Please start initiative and add your players and  monsters.'
    return f'embed -title "{title}" -desc "{desc_text}" -footer "{footer}"'

combatants = c.combatants

# Map-related variables
map_state = {"current_map": None, "size": None, "bg_image": None}
map_base_url = get("otfbm_base_url", "http://otfbm.io/")
mapsize = get("mapSize", "20x20")
out = {}
alph = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"

occupied_positions = set()

def place_combatants(combatants, is_monster):
    width, height = mapl.parse_mapsize(map_state.get("size"))
    
    if is_monster:
        x_range = range(width // 2 + 1, width + 1)
    else:
        x_range = range(1, width // 2 + 1)
    
    y_range = range(1, height + 1)
    for combatant in combatants:
        if typeof(combatant) == "SimpleGroup":
            place_combatants(combatant.combatants, is_monster)
        elif combatant.name.lower() not in ['dm', 'map', 'lair']:
            out[combatant.name] = out.get(combatant.name, {})
            
            # Mapping size categories to size letters and grid sizes
            size_map = {
                'Tiny': ('T', 1),
                'Small': ('S', 1),
                'Medium': ('M', 1),
                'Large': ('L', 2),
                'Huge': ('H', 3),
                'Gargantuan': ('G', 4)
            }
            
            # Fetch the monster's size from the custom database
            if combatant.monster_name:
                mon_size = get_monster_data(combatant.monster_name, 'meta')
                if mon_size:
                    mon_size = mon_size.split()[0]
                else:
                    mon_size = 'Medium'
            else:
                # Default to 'Medium' size for player characters
                mon_size = 'Medium'
            
            # Get size letter and grid size
            size_info = size_map.get(mon_size, ('M', 1))
            size_letter, mon_size_grid = size_info
            
            position_found = False
            attempts = 0
            max_attempts = 100  # To prevent infinite loops
            while not position_found and attempts < max_attempts:
                x = randchoice(x_range)
                y = randchoice(y_range)
                position_clear = True
                for dx in range(mon_size_grid):
                    for dy in range(mon_size_grid):
                        pos = (x + dx, y + dy)
                        if pos in occupied_positions or x + dx > width or y + dy > height:
                            position_clear = False
                            break
                    if not position_clear:
                        break
                if position_clear:
                    for dx in range(mon_size_grid):
                        for dy in range(mon_size_grid):
                            occupied_positions.add((x + dx, y + dy))
                    
                    # Add safeguard for x value
                    x = max(1, min(x, len(alph)))
                    location = f"{alph[x-1]}{y}"
                    
                    out[combatant.name]['location'] = location
                    position_found = True
                attempts += 1
            if not position_found:
                err(f"Could not place {combatant.name} on the map without overlapping.")
            
            # Set size letter
            out[combatant.name]['size'] = size_letter
            
            # Set color
            out[combatant.name]['color'] = 'r' if is_monster else 'g'
            
            # Add note to the combatant without Tokensize
            note = (f"Location: {location} | Color: {out[combatant.name]['color']} | "
                    f"Size: {size_letter} ({mon_size})")
            combatant.set_note(note)
            map_state["combatants"] = map_state.get("combatants", {})
            map_state["combatants"].update(out)

def find_best_target(monster, target_names, max_surrounding=2):
    if monster.stats.intelligence < 10:
        return target_names[randint(len(target_names))]
    
    targets = [c.get_combatant(name) for name in target_names if c.get_combatant(name)]
    target_hp = [(t, t.hp) for t in targets if t.hp is not None and t.hp > 0]
    
    if not target_hp:
        return target_names[randint(len(target_names))]
    
    def count_surrounding_monsters(target):
        target_location = get_combatant_location(target)
        if not target_location:
            return 0, False
        surrounding_cells = get_surrounding_positions(target_location)
        monster_count = 0
        large_monster_present = False
        for cell in surrounding_cells:
            monster = get_monster_at_location(cell, c)
            if monster:
                monster_count += 1
                if is_large_monster(monster):
                    large_monster_present = True
        return monster_count, large_monster_present
    
    def get_combatant_location(combatant):
        if combatant.note:
            note_parts = combatant.note.split('|')
            for part in note_parts:
                if part.strip().lower().startswith('location:'):
                    return part.split(':')[1].strip()
        return None
    
    def get_monster_at_location(cell, combat):
        for combatant in combat.combatants:
            if autolib.isMonster(combatant) and get_combatant_location(combatant) == cell:
                return combatant
        return None
    
    def is_large_monster(monster):
        if monster.note:
            note_parts = monster.note.split('|')
            for part in note_parts:
                if part.strip().lower().startswith('size:'):
                    size = part.split(':')[1].strip().lower()
                    return size in ['l', 'h', 'g', 'large', 'huge', 'gargantuan']
        return False
    
    # Sort targets by HP and intelligence level
    if monster.stats.intelligence >= 17:
        sorted_targets = core.sorted(target_hp, key=lambda x: x[1])
    else:
        # Weighted random selection favoring lower HP targets
        weights = [max(1, 100 - t[1]) for t in target_hp]
        sorted_targets = [t for t, _ in core.sorted(core.zip(target_hp, weights), key=lambda x: x[1], reverse=True)]
    
    for target, _ in sorted_targets:
        monster_count, large_monster_present = count_surrounding_monsters(target)
        if monster_count < max_surrounding and not large_monster_present:
            return target.name
    
    # If all preferred targets are surrounded or near large monsters, choose the least surrounded one without a large monster
    valid_targets = [t for t in sorted_targets if not count_surrounding_monsters(t[0])[1]]
    if valid_targets:
        return min(valid_targets, key=lambda x: count_surrounding_monsters(x[0])[0])[0].name
    
    # If all targets have large monsters nearby, choose a random target from the valid ones (those with HP > 0)
    return randchoice([t.name for t, _ in target_hp]) if target_hp else None

def fetch_and_store_monster_data():
    monster_data = {}
    for combatant in c.combatants:
        if combatant.monster_name:
            full_data = get_monster_data(combatant.monster_name, None)
            if full_data:
                monster_data[combatant.name] = full_data
    
    # Store the data in combat metadata
    c.set_metadata('monster_data', dump_json(monster_data))

def get_stored_monster_data(monster_name, field=None):
    monster_data = load_json(c.get_metadata('monster_data', '{}'))
    if monster_name in monster_data:
        if field:
            return monster_data[monster_name].get(field)
        return monster_data[monster_name]
    return None

def update_stored_monster_data(monster_name, data):
    monster_data = load_json(c.get_metadata('monster_data', '{}'))
    monster_data[monster_name] = data
    c.set_metadata('monster_data', dump_json(monster_data))

def remove_stored_monster_data(monster_name):
    monster_data = load_json(c.get_metadata('monster_data', '{}'))
    if monster_name in monster_data:
        del monster_data[monster_name]
        c.set_metadata('monster_data', dump_json(monster_data))

def get_aoe_attacks(monster_name):
    aoe_keywords = ["cone", "line", "radius", "sphere", "cube", "cylinder"]
    monster_attacks = []

    monster_data = get_stored_monster_data(monster_name)

    if not monster_data:
        return []

    action_fields = ['Actions', 'Traits', 'Legendary Actions']
    actions_text = ' '.join(monster_data.get(field, '') for field in action_fields)
    sentences = actions_text.replace('\n', ' ').split('. ')
    
    for i, sentence in enumerate(sentences):
        sentence_lower = sentence.lower()
        if any(keyword in sentence_lower for keyword in aoe_keywords) and '-foot' in sentence_lower:
            attack_name = sentences[i-1].strip() if i > 0 else sentence.split('(')[0].strip()
            size = None
            shape = None
            width = None
            words = sentence_lower.split()
            for j, word in enumerate(words):
                if '-foot' in word:
                    size_parts = word.split('-')
                    if size_parts[0].isdigit():
                        size = size_parts[0]
                if word in aoe_keywords:
                    shape = word
                    possible_widths = [words[k] for k in range(max(0, j-2), min(j+4, len(words)))]
                    for item in possible_widths:
                        if item.isdigit() and (words[words.index(item) + 1] in ['feet', 'foot']):
                            width = item
            if size and shape:
                attack_info = {
                    'name': attack_name,
                    'size': int(size),
                    'shape': shape,
                    'width': int(width) if width else None
                }
                monster_attacks.append(attack_info)
    
    return monster_attacks

def get_map_size():
    mapsize = "10x10"  # Default map size
    maxSize = 99

    # Check if there's a map combatant with size information
    c = combat()
    if c:
        for combatant in c.combatants:
            for attack in combatant.attacks:
                if attack.name == 'map':
                    mapinfo = attack.raw.automation[-1].text
                    mapinfo = mapinfo.split(' ~ ')
                    mapinfo = {x[0].lower():x[1] for x in [item.split(': ') for item in mapinfo]}
                    if mapinfo.get('size'):
                        mapsize = mapinfo.get('size')
                    break
            if mapsize != "10x10":
                break

    # Parse the mapsize
    if mapsize != "JSON":
        if ":" in mapsize:
            mapsize = mapsize.split(':')[1]
        if mapsize[0].isdigit():
            mapSplitX, mapSplitY = mapsize.lower().split('x')
            mapX = min(int(mapSplitX) if mapSplitX.isdigit() else 1, maxSize)
            mapY = min(int(mapSplitY) if mapSplitY.isdigit() else 1, maxSize)
        else:
            baseAlph = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
            alph = []
            for index in range(maxSize):
                letter = ""
                if index // 26:
                    letter = baseAlph[(index // 26) - 1]
                letter += baseAlph[index % 26]
                alph.append(letter)
            mapX = alph.index(''.join(x.upper() for x in mapsize if x.isalpha())) + 1
            mapY = int(''.join(y for y in mapsize if y.isdigit()))
    else:
        mapX = mapY = 10  # Default size for JSON

    return mapX, mapY

def find_best_aoe_position(monster, aoe_attack, target_names):
    best_position = None
    max_targets = 0
    monster_map_data = mapl.parse_note(monster.note)
    monster_location = monster_map_data.get('location', None)
    if not monster_location:
        return None

    mapX, mapY = get_map_size()

    # Generate positions in the monster's line of sight/direction
    # For simplicity, we'll consider positions in front of the monster
    # Assuming the monster is facing towards the majority of targets

    # Find the center position of all targets to determine general direction
    target_positions = []
    for target_name in target_names:
        target = c.get_combatant(target_name)
        if target:
            target_map_data = mapl.parse_note(target.note)
            target_location = target_map_data.get('location', None)
            if target_location:
                coords = mapl.loc_to_coords(target_location)
                target_positions.append(coords)

    if not target_positions:
        return None

    # Calculate average position of targets
    avg_x = sum(pos[0] for pos in target_positions) / len(target_positions)
    avg_y = sum(pos[1] for pos in target_positions) / len(target_positions)
    direction_vector = [avg_x - mapl.loc_to_coords(monster_location)[0], avg_y - mapl.loc_to_coords(monster_location)[1]]

    # Normalize direction vector
    length = sqrt(direction_vector[0] ** 2 + direction_vector[1] ** 2)
    if length == 0:
        direction_vector = [0, 1]  # Default direction
    else:
        direction_vector = [direction_vector[0] / length, direction_vector[1] / length]

    # Check positions in the direction the monster is facing
    for distance in range(1, max(mapX, mapY)):
        x = mapl.loc_to_coords(monster_location)[0] + int(direction_vector[0] * distance)
        y = mapl.loc_to_coords(monster_location)[1] + int(direction_vector[1] * distance)
        if x < 0 or y < 1 or x >= len(alph) or y > mapY:
            break
        position = f"{alph[x]}{y}"
        affected_targets = count_affected_targets(position, aoe_attack, target_names)
        if affected_targets > max_targets:
            max_targets = affected_targets
            best_position = position

    return best_position


def count_affected_targets(position, aoe_attack, targets):
    affected = 0

    for target in targets:
        target_map_data = mapl.parse_note(c.get_combatant(target).note)
        target_location = target_map_data.get('location', None)
        if target_location and is_in_aoe(position, target_location, aoe_attack):
            affected += 1
    return affected

def is_in_aoe(origin, target, aoe_attack):
    ox, oy = alph.index(origin[0]), int(origin[1:])
    tx, ty = alph.index(target[0]), int(target[1:])
    dx, dy = abs(tx - ox), abs(ty - oy)
    distance = max(dx, dy) * 5  # Assuming 5ft per square

    if aoe_attack['shape'] in ['cone', 'sphere', 'radius']:
        return distance <= aoe_attack['size']
    elif aoe_attack['shape'] == 'line':
        return (dx == 0 or dy == 0 or dx == dy) and distance <= aoe_attack['size']
    elif aoe_attack['shape'] in ['cube', 'cylinder']:
        return dx <= aoe_attack['size'] // 5 and dy <= aoe_attack['size'] // 5

    return False

def distance(pos1, pos2):
    x1, y1 = alph.index(pos1[0].upper()), int(pos1[1:])
    x2, y2 = alph.index(pos2[0].upper()), int(pos2[1:])
    dx = abs(x2 - x1)
    dy = abs(y2 - y1)
    
    # D&D 5e uses a simplified diagonal movement rule
    # where every other diagonal counts as 10 feet instead of 5
    diagonals = min(dx, dy)
    straight = abs(dx - dy)
    
    return (diagonals * 5) + (straight * 5)

def draw_aoe_overlay(monster, aoe_attack, position, targets):

    shapeDict = [{"type": "circle",       "name":"c",  "num": [3], "args": ("size", "color", "loc")},
               {"type": "circletop",    "name":"ct", "num": [3], "args": ("size", "color", "loc")},
               {"type": "circlecorner", "name":"co", "num": [3], "args": ("size", "color", "loc")},
               {"type": "cone",         "name":"t",  "num": [4], "args": ("size", "color", "loc", "eloc")},
               {"type": "line",         "name":"l",  "num": [5], "args": ("size", "width", "color", "loc", "eloc")},
               {"type": "arrow",        "name":"a",  "num": [3], "args": ("color", "loc", "eloc")},
               {"type": "square",       "name":"s",  "num": [3,4], "args": ("size", "color", "loc", "eloc")},
               {"type": "squaretop",    "name":"st", "num": [3,4], "args": ("size", "color", "loc", "eloc")}]

    color = 'r'  # Default color for AoE
    shape = aoe_attack['shape']
    size = aoe_attack.get('size', 10)
    
    # Create a dictionary mapping shape names to their short codes
    shape_to_code = {item['type']: item['name'] for item in shapeDict}
    
    if shape in ['sphere', 'radius', 'cube', 'cylinder']:
        shape_code = shape_to_code['circle' if shape in ['sphere', 'radius'] else 'square']
        return f"{shape_code}{size}{color}{position}"
    
    if shape in ['cone', 'line']:
        nearest_target = min(targets, key=lambda t: distance(position, mapl.parse_note(c.get_combatant(t).note).get('location', 'A1')))
        nearest_pos = mapl.parse_note(c.get_combatant(nearest_target).note).get('location', 'A1')
        shape_code = shape_to_code[shape]
        return f"{shape_code}{size},{aoe_attack.get('width', size) if shape == 'line' else ''}{color}{position}{nearest_pos}".rstrip(',')
    
    return None

def find_adjacent_position(monster_location, target_position):
    mx, my = alph.index(monster_location[0]), int(monster_location[1:])
    tx, ty = alph.index(target_position[0]), int(target_position[1:])
    
    adjacent_positions = [
        (mx-1, my), (mx+1, my), (mx, my-1), (mx, my+1),
        (mx-1, my-1), (mx-1, my+1), (mx+1, my-1), (mx+1, my+1)
    ]
    
    closest_position = min(adjacent_positions, key=lambda p: ((p[0]-tx)**2 + (p[1]-ty)**2))
    return f"{alph[closest_position[0]]}{closest_position[1]}"

def get_targets_in_aoe(monster_location, aoe_attack, target_names):
    affected_targets = []
    for target_name in target_names:
        target = c.get_combatant(target_name)
        if target:
            target_map_data = mapl.parse_note(target.note)
            target_location = target_map_data.get('location', None)
            if target_location and is_in_aoe(monster_location, target_location, aoe_attack):
                affected_targets.append(target_name)
    return affected_targets

def move_towards(start, end, distance, occupied_positions):
    start_pos = mapl.loc_to_coords(start)
    end_pos = mapl.loc_to_coords(end)
    total_distance = mapl.distance(start_pos, end_pos) * 5
    dxy = mapl.subtract_coords(end_pos, start_pos)
    ratio = min(distance / total_distance, 1) if 0 < total_distance else 0
    move_coords = mapl.add_coords(start_pos, mapl.scale_coords(dxy, ratio))
    new_location = mapl.coords_to_loc(move_coords)

    # Check if the new location is occupied
    if new_location in occupied_positions:
        new_location = find_nearest_unoccupied_position(start, end, occupied_positions)
    
    # Calculate actual movement for the arrow
    new_pos = mapl.loc_to_coords(new_location)
    distanceT = round(mapl.distance(start_pos, new_pos)) * 5
    
    # Generate arrow overlay with correct syntax
    color = 'r' # Use red color for the arrow
    arrow = f"*a{distanceT}{color}{start}{new_location}"
    
    return new_location, arrow

def create_arrow_overlay(start_location, end_location):
    start_pos = mapl.loc_to_coords(start_location)
    end_pos = mapl.loc_to_coords(end_location)
    distanceT = round(mapl.distance(start_pos, end_pos)) * 5
    
    # Generate arrow overlay with correct syntax
    colr = 'r' # Use red color for the arrow
    arrow = f"*a{distanceT}{colr}{start_location}{end_location}"
    return arrow

def update_monster_position(monster, new_location):
    # Parse the current note
    note_data = mapl.parse_note(monster.note)
    old_location = note_data.get('location', None)
    size_letter = note_data.get('size', 'M')
    size_map = {'T': 1, 'S': 1, 'M': 1, 'L': 2, 'H': 3, 'G': 4}
    mon_size_grid = size_map.get(size_letter.upper(), 1)

    # Remove old positions from occupied_positions
    if old_location:
        old_positions = get_occupied_positions(old_location, mon_size_grid)
        occupied_positions.difference_update(old_positions)

    # Update the location
    note_data['location'] = new_location

    # Use the update_combatant_note function to set the new note
    mapl.update_combatant_note(monster, **note_data)

    # Update the out dictionary
    out[monster.name] = out.get(monster.name, {})
    out[monster.name]['location'] = new_location

    # Add new positions to occupied_positions
    new_positions = get_occupied_positions(new_location, mon_size_grid)
    occupied_positions.update(new_positions)

def get_occupied_positions(location, size_grid):
    """
    Given a location (e.g., 'E5') and size in grid cells, return a set of occupied positions.
    """
    pos = mapl.loc_to_coords(location)
    positions = set()
    for dx in range(size_grid):
        for dy in range(size_grid):
            positions.add((pos[0] + dx, pos[1] + dy))
    return positions

def find_unoccupied_positions_near_target(target_location, monster_size_grid, occupied_positions, map_width, map_height):
    # Get positions occupied by target
    target_size_grid = 1  # Assume target is size 1 for now
    target_pos = mapl.loc_to_coords(target_location)
    target_positions = mapl.box(target_pos, target_size_grid)
    """target_positions = get_occupied_positions(target_location, target_size_grid)
    Get all adjacent positions to the target's occupied positions
    adjacent_positions = set()
    for pos in target_positions:
        x, y = pos
        for dx in range(-monster_size_grid, monster_size_grid + 1):
            for dy in range(-monster_size_grid, monster_size_grid + 1):
                if dx == 0 and dy == 0:
                    continue
                adj_x = x + dx
                adj_y = y + dy
                # Check bounds
                if 0 <= adj_x < len(alph) and 1 <= adj_y <= map_height:
                    adjacent_positions.add((adj_x, adj_y))"""
    adjacent_positions = mapl.melee_box(monster_size_grid, target_pos, target_size_grid)

    # Now, for each adjacent position, check if the monster can occupy it
    available_positions = []
    for pos in adjacent_positions:
        x, y = pos
        # Check if monster can occupy positions from (x, y) to (x + size - 1, y + size - 1)
        can_occupy = True
        for dx in range(monster_size_grid):
            for dy in range(monster_size_grid):
                check_pos = (x + dx, y + dy)
                if check_pos in occupied_positions:
                    can_occupy = False
                    break
                # Check bounds
                if check_pos[0] >= len(alph) or check_pos[1] > map_height:
                    can_occupy = False
                    break
            if not can_occupy:
                break
        if can_occupy:
            available_positions.append((x, y))
    return available_positions

def choose_closest_position_coords(monster_location, positions):
    monster_coords = mapl.loc_to_coords(monster_location)

    # Calculate distances to each position
    distances = [(mapl.distance(monster_coords, pos), pos) for pos in positions]
    distances.sort()
    return distances[0][1] if distances else None

def get_monster_size(monster_name):
    monster_data = get_stored_monster_data(monster_name)
    if monster_data:
        meta = monster_data.get('meta', '')
        return meta.split()[0] if meta else 'Medium'  # Default to Medium if not found
    return 'Medium'

def get_monster_speed(monster_name):
    speed_data = get_stored_monster_data(monster_name, 'Speed')
    if speed_data:
        walk_speed = fly_speed = 0
        speed_parts = speed_data.lower().replace(',', '').split()
        for i, part in enumerate(speed_parts):
            if part.isdigit():
                if i > 0 and speed_parts[i-1] == 'fly':
                    fly_speed = int(part)
                else:
                    walk_speed = int(part)
        return max(walk_speed, fly_speed), 'fly' if fly_speed > walk_speed else 'walk'
    return 30, 'walk'  # Default speed if not found

def get_monster_data(monster_name, data_needed=None):
    if not monster_name:
        return None
    db1 = '21934e43-b1aa-49b5-b252-68c0d78ed04c'
    db2 = '24a1ea26-3c5b-4c2c-b528-113b857f9d34'
    db3 = '9ca349e9-96f9-499d-8a2b-1359a5b989ba'
    db4 = '48d73cd1-0224-4d8c-b723-d4a6bb4b2bf8'
    db5 = '506d5812-54b6-47d8-aa48-03b0d9436999'
    db6 = '710387e2-6c16-4b8f-9e04-65efa22a47b0'
    db7 = 'f638dc80-082c-4aeb-aa03-6c8801ad9449'
    db = [db1,db2,db3,db4,db5,db6,db7]
    for gvar_str in db:
        db = load_json(get_gvar(gvar_str))
        for mon_datum in db:
            if monster_name.casefold() == mon_datum["name"].casefold():
                obtained_monster_data = mon_datum.get(data_needed, '') if data_needed else mon_datum
                return obtained_monster_data
    return False

def filter(func, iterable):
    return [item for item in iterable if func(item)]

def reversed(sequence):
    result = []
    for i in range(len(sequence) - 1, -1, -1):
        result.append(sequence[i])
    return result

def get_surrounding_positions(center):
    x = alph.index(''.join(filter(str.isalpha, center)).upper())
    y = int(''.join(filter(str.isdigit, center)))
    surrounding = [
        (x-1, y-1), (x, y-1), (x+1, y-1),
        (x-1, y),             (x+1, y),
        (x-1, y+1), (x, y+1), (x+1, y+1)
    ]
    return [f"{alph[pos[0]]}{pos[1]}" for pos in surrounding if 0 <= pos[0] < len(alph) and 1 <= pos[1] <= 20]

def find_nearest_unoccupied_position(start, end, occupied_positions):
    end_pos = mapl.loc_to_coords(end)
    end_surrounding = [mapl.coords_to_loc(p) for p in mapl.out_box(end_pos, 0)]
    available_positions = [pos for pos in end_surrounding if pos not in occupied_positions]
    
    if not available_positions:
        return start  # No available positions, stay at current position
    
    # Find the nearest available position
    start_pos = mapl.loc_to_coords(start)
    return min(available_positions, key=lambda pos: mapl.distance(start_pos, mapl.loc_to_coords(pos)) * 5)

def get_attack_reach(attack_str):
    attack_str = attack_str.lower()
    if 'reach' in attack_str:
        words = attack_str.split()
        for i, word in enumerate(words):
            if word == 'reach' and i + 1 < len(words):
                reach = ''.join(filter(str.isdigit, words[i+1]))
                if reach:
                    return int(reach)
    return 8  # Default melee reach

def get_max_attack_reach(attacks):
    max_reach = 8
    for attack in attacks:
        reach = get_attack_reach(str(attack))
        if reach > max_reach:
            max_reach = reach
    return max_reach

def get_spell_range(spell_name):
    spell_data = load_json(get_gvar('00d6334d-af6c-46ac-b810-752465e0ad33'))
    spell_name = spell_name.strip('"')  # Remove quotes if present
    for spell in spell_data:
        if spell['name'].lower() == spell_name.lower():
            range_str = spell['range']
            # Extract the numeric value from the range string
            range_value = ''.join(filter(str.isdigit, range_str))
            return int(range_value) if range_value else 30  # Default to 30 if no numeric value found
    return 30  # Default range if spell not found

def process_monster_turn(indexed_combatant, targets, c, out, overlays, desc, command_list):
    monster = c.get_combatant(indexed_combatant)
    if not monster:
        desc.append(f"Could not find combatant: {indexed_combatant}")
        return

    monster_name = monster.monster_name
    curr_hp = monster.hp

    # Fetch monster data if not already stored
    if not get_stored_monster_data(monster_name):
        fetch_and_store_monster_data()

    # Check if the monster is already dead at the start of its turn
    if monster.hp <= 0:
        remove_dead_monster(c, monster, out, desc)
        map_url = mapl.generate_map_image(overlays)
        command_list.append(f'{pref}embed -title "Skipping dead monster: {monster_name}" -desc "{monster_name} has been defeated and removed from the map. Its turn will be skipped." -image "{map_url}" -footer "{footer}"')
        command_list.append(f'{pref}i n')  # Skip to next turn
        return

    # Get location from note
    monster_map_data = mapl.parse_note(monster.note)
    monster_location = monster_map_data.get('location', None)
    monster_size_mod = mapl.get_size_mod(monster_map_data.get('size', 'M'))

    # Check if map is present
    map_present = mapl.mapPresent()
    if map_present and monster_location:
        # Get occupied positions to avoid collisions
        occupied_positions = mapl.get_occupied_coords(monster.name)

        ### AoE ###
        aoe_attacks = get_aoe_attacks(monster.name)

        if aoe_attacks:
            aoe_attack = randchoice(aoe_attacks)

            # Create a list of all potential targets (excluding the monster itself)
            all_combatants = [c.name for c in c.combatants if c.name.lower() not in ['map', 'dm', 'lair']]
            potential_targets = [name for name in all_combatants if name != monster.name]

            # Find the best position for the AoE attack
            best_position = find_best_aoe_position(monster, aoe_attack, potential_targets)

            if best_position:
                # Calculate the distance to the best position
                start_pos = mapl.loc_to_coords(monster_location)
                end_pos = mapl.loc_to_coords(best_position)
                distance_to_position = mapl.distance(start_pos, end_pos) * 5

                monster_speed = get_monster_speed(monster_name)

                # Move the monster if needed
                if distance_to_position > 0:
                    move_distance = min(monster_speed, distance_to_position)
                    new_location, arrow = move_towards(monster_location, best_position, move_distance, occupied_positions)
                    update_monster_position(monster, new_location)
                    occupied_positions.add(new_location)
                    if arrow:
                        overlays.append(arrow)
                    monster_location = new_location
                    desc.append(f"{indexed_combatant} moves {int(move_distance)} ft. towards the optimal position for its AoE attack.")

                    # Display the updated map after movement
                    map_state["combatants"] = out
                    map_url = mapl.generate_map_image(overlays)
                    command_list.append(f'{pref}embed -title "Monster Movement: {monster.name}" -desc "{desc[-1]}" -image "{map_url}" -footer "{footer}"')

                # Adjust the AoE position for cone and line attacks
                if aoe_attack['shape'] in ['cone', 'line']:
                    best_position = find_adjacent_position(monster_location, best_position)

                # Create and add the AoE overlay
                overlay = draw_aoe_overlay(monster, aoe_attack, best_position, potential_targets)
                if overlay:
                    overlays.append(f"*{overlay}")
                    desc.append(f"{monster.name} uses {aoe_attack['name']} starting at {monster_location} towards {best_position}")

                    # Display the map with the AoE overlay
                    map_url = mapl.generate_map_image(overlays)
                    command_list.append(f'{pref}embed -title "AoE Attack: {monster.name}" -desc "{desc[-1]}" -image "{map_url}" -footer "{footer}"')

                    # Find targets within the AoE
                    affected_targets = get_targets_in_aoe(monster_location, aoe_attack, potential_targets)

                    # Add the attack command targeting all affected combatants
                    if affected_targets:
                        target_string = " -t ".join(affected_targets)
                        command_list.append(f'{ctx.prefix}i a "{aoe_attack["name"]}" -t {target_string} -phrase ":robot: _Triggered by auto monster AI_"')
                    else:
                        desc.append(f"No targets were caught in the AoE of {aoe_attack['name']}.")

                    command_list.append(f'{ctx.prefix}i n')
                    return
        ### AoE ###

        chosen_target = find_best_target(monster, targets)
        target_combatant = c.get_combatant(chosen_target)
        if not target_combatant:
            desc.append(f"Could not find target: {chosen_target}")
            return

        target_map_data = mapl.parse_note(target_combatant.note)
        target_location = target_map_data.get('location', None)
        target_size_mod = mapl.get_size_mod(target_map_data.get('size', 'M'))

        if target_location:
            start_pos = mapl.loc_to_coords(monster_location)
            monster_box = mapl.box(start_pos, monster_size_mod)
            
            target_pos = mapl.loc_to_coords(target_location)
            target_box = mapl.box(target_pos, target_size_mod)
            
            monster_speed = get_monster_speed(monster_name)[0]
            max_attack_reach = get_max_attack_reach(monster.attacks)
            nearest_dist, monster_nearest, target_nearest = mapl.get_nearest_coords(
                monster_box, target_box
            )
            distance = nearest_dist * 5
            
            # Check if the monster is a spellcaster
            spell_monst = monster.spellbook.caster_level

            # Before moving, display the map
            map_state["combatants"] = out
            toggle_monster_color(monster, 'p')
            # map_url = mapl.generate_map_image(overlays)
            # command_list.append(f'''{pref}embed -title "Monsters are deciding their actions..." -image "{map_url}" -footer "{footer}"''')

            monster_size_mod = mapl.get_size_mod(monster_map_data.get('size', 'M'))
            occupied_positions = mapl.get_occupied_coords(monster.name, monster_size_mod)
            # occupants = mapl.get_occupants(monster.name, monster_size_mod)
            # occupied_positions = set(out[name].get('location') for name in out if 'location' in out[name])
            
            # Spellcasting logic
            if spell_monst:
                spell_data = load_json(get_gvar("a1e23cdf-0510-480d-a616-59e2c46780ac"))
                spell_list = [spell.name for spell in monster.spellbook.spells]
                spell_viable = False
                chosen_spell = None
                chosen_spell_level = 0

                # Create a list of viable spells
                viable_spells = []
                for spell in spell_list:
                    if spell in spell_data:
                        spell_level = spell_data[spell]
                        if monster.spellbook.can_cast(spell, spell_level):
                            viable_spells.append((spell, spell_level))

                # If there are viable spells, choose one randomly
                if viable_spells:
                    chosen_spell, chosen_spell_level = randchoice(viable_spells)
                    spell_viable = True

                if spell_viable:
                    # Check if the monster needs to move to cast the spell
                    spell_range = get_spell_range(chosen_spell)
                    ideal_distance = max(30, spell_range - 30)  # Stay 30 ft away from max range if possible
                    
                    if distance != ideal_distance:
                        move_distance = min(monster_speed, abs(distance - ideal_distance))
                        movement_direction = "towards" if distance > ideal_distance else "away from"
                        new_location, arrow = move_towards(monster_location, target_location, move_distance, occupied_positions)
                        update_monster_position(monster, new_location)
                        occupied_positions.add(new_location)
                        if arrow:
                            overlays.append(arrow)
                        monster_location = new_location
                        desc.append(f"{indexed_combatant} moves {int(move_distance)} ft. {movement_direction} {chosen_target} for a better vantage point.")
                        
                        # After movement, display the updated map
                        map_state["combatants"] = out
                        map_url = mapl.generate_map_image(overlays)
                        command_list.append(f'{pref}embed -title "Monster Movement: {monster.name}" -desc "{desc[-1]}" -image "{map_url}" -footer "{footer}"')
                    else:
                        desc.append(f"{indexed_combatant} holds position, already at an ideal vantage point.")
                    
                    # Cast the spell
                    command_list.append(f'{pref}i cast "{chosen_spell}" -t {chosen_target} -l {chosen_spell_level} -phrase ":robot: _Triggered by auto monster AI_"')
                    desc.append(f"{indexed_combatant} casts {chosen_spell} at {chosen_target}.")
                    command_list.append(f'{pref}i n')
                    return

            # Melee combat logic (if not a spellcaster or out of spell slots)
            if max_attack_reach < distance:
                move_distance = min(monster_speed, distance - max_attack_reach)
                if move_distance < distance - max_attack_reach:                  
                    # Monster needs to dash
                    move_distance = min(monster_speed * 2, distance - max_attack_reach)
                    
                    # map_size = mapl.parse_mapsize(mapl.get_map_info()[0].get("size"))
                    # ircle = mapl.circle(start_pos, (monster_speed * 2) / 5, bounds=[0, 1, map_size[0], map_size[1]])
                    # for oco, oco_info in occupants.items():
                    #   circle = [cc for cc in circle if cc not in oco_info.box] #+ oc_melee
                    #   nearest_dist = mapl.get_nearest_coords([start_pos], oco_info.box, move_distance / 5)[0]
                    #   if 0 <= nearest_dist:
                    #       oc_melee = [p for p in oco_info.melee if mapl.distance(p, start_pos) * 5 <= move_distance]    

                    new_location, arrow = move_towards(monster_location, target_location, move_distance, occupied_positions)
                    update_monster_position(monster, new_location)
                    occupied_positions.add(new_location)
                    if arrow:
                        overlays.append(arrow)
                    monster_location = new_location
                    desc.append(f"{indexed_combatant} dashes {int(move_distance)} ft. towards {chosen_target}.")
                    map_state["combatants"] = out
                    map_url = mapl.generate_map_image(overlays)
                    command_list.append(f'{pref}embed -title "Monster Dashes: {monster.name}" -desc "{desc[-1]}" -image "{map_url}" -footer "{footer}"')
                    command_list.append(f'{pref}i n')
                    return
                else:
                    target_melee_positions = mapl.melee_box(monster_size_mod, target_pos, target_size_mod)
                    unoccupied_melee_positions = [pos for pos in target_melee_positions if pos not in occupied_positions]
                    if 0 < len(unoccupied_melee_positions):
                        target_melee_positions = unoccupied_melee_positions
                    melee_position = mapl.get_nearest_coords([start_pos], target_melee_positions)[2]
                    melee_location = mapl.coords_to_loc(melee_position)
                    new_location, arrow = melee_location, None
                    if 0 < len(unoccupied_melee_positions):
                        arrow = create_arrow_overlay(monster_location, melee_location)
                    else:
                        new_location, arrow = move_towards(monster_location, melee_location, move_distance, occupied_positions)
                    update_monster_position(monster, new_location)
                    occupied_positions.add(new_location)
                    if arrow:
                        overlays.append(arrow)
                    start_pos = mapl.loc_to_coords(monster_location)
                    end_pos = mapl.loc_to_coords(new_location)
                    moved_distance = mapl.distance(start_pos, end_pos) * 5
                    new_monster_box = mapl.box(end_pos, monster_size_mod)
                    distance = round(mapl.get_nearest_coords(new_monster_box, target_box)[0]) * 5
                    desc.append(f"{indexed_combatant} moves {int(moved_distance)} ft. towards {chosen_target}.")
            else:
                desc.append(f"{indexed_combatant} holds position to attack {chosen_target}.")

            # After movement, display the updated map
            map_state["combatants"] = out
            map_url = mapl.generate_map_image(overlays)
            command_list.append(f'{pref}embed -title "Monster Movement: {monster.name}" -desc "{desc[-1]}" -image "{map_url}" -footer "{footer}"')

        else:
            desc.append(f"Could not find location for target: {chosen_target}")

    else:
        chosen_target = targets[randint(len(targets))]
        distance = 8  # Assume adjacent if no map
        desc.append(f"{indexed_combatant} attacks {chosen_target}.")

    # Attack logic
    
    # command_list.append(f"{pref}echo DISTANCEEEE: {distance}")
    if distance <= get_max_attack_reach(monster.attacks) and (curr_hp > 0 or autolib.onDeath(indexed_combatant, c.combatants) == "relentless"):
        # Multiattack logic
        mon_actions = autolib.getActions(monster_name, autolib.buildDB())
        multi_atks = autolib.getMultiAttacks(mon_actions)

        if multi_atks:
            for atk, num in multi_atks.items():
                atkr = autolib.resolveVersatile(atk)
                command_list.append(f'{pref}i a "{atkr}" -rr {num} autoc -t {chosen_target} -phrase ":robot: _Triggered by auto monster AI_ :crossed_swords: Multiattack :crossed_swords:"')
            command_list.append(f'{pref}i n')
        else:
            chosen_atk_string = autolib.getAttack(indexed_combatant, c.combatants)
            command_list.append(f'{pref}i a "{chosen_atk_string}" -t {chosen_target} autoc -phrase ":robot: _Triggered by auto monster AI_"')
            command_list.append(f'{pref}i n')    
    elif curr_hp <= 0:
        on_death = autolib.onDeath(indexed_combatant, c.combatants)
        if on_death:
            target_string = f"-t {chosen_target}" if "death" in on_death else ""
            command_list.append(f'{pref}i a "{on_death}" {target_string} -phrase ":robot: _Triggered by auto monster AI_"')
        else:
            desc.append(f"Skipping dead monster: {indexed_combatant}")
            command_list.append(f'{pref}i n')
    else:
        desc.append(f"{indexed_combatant} couldn't reach {chosen_target} to attack.")
        command_list.append(f'{pref}i n')

    if monster.hp <= 0:
        remove_dead_monster(c, monster, out, desc)
        map_url = mapl.generate_map_image(overlays)
        command_list.append(f'{pref}embed -title "Skipping dead monster: {monster_name}" -desc "{monster_name} has been defeated and removed from the map. Its turn will be skipped." -image "{map_url}" -footer "{footer}"')
        return

def remove_dead_monster(combat, monster, out, desc):
    if monster.name in out:
        out.pop(monster.name)
    desc.append(f"{monster.name} has fallen and been removed from the map.")

def toggle_monster_color(monster, new_color):
    note_dict = mapl.parse_note(monster.note)
    original_color = note_dict.get('color', 'r')
    note_dict['color'] = new_color
    new_note = ' | '.join(f"{k.title()}: {v}" for k, v in note_dict.items())
    monster.set_note(new_note)
    
    if monster.name in out:
        out[monster.name]['color'] = new_color
    
    return original_color


def load_specific_map(map_subtext):
    map_name, map_data, matches = presets.find_map_by_subtext(map_subtext)
    if not matches:
        return False, f"No maps found matching '{map_subtext}'. Use `{cmd} map list` to see available maps."
    
    # Update map_state with new map data
    map_state["current_map"] = map_name
    map_state["size"] = map_data["size"]
    map_state["mapoptions"] = map_data["cell_pixel"]
    map_state["bg_image"] = map_data["image"]
    
    # Get the current map combatant
    map_combatant = mapl.mapPresent()
    
    if not map_combatant:
        return False, f"Map combatant not found. You can manually add it using:\n`!i add 0 Map -p 20`\n\n**RECOMMENDED ACTION**:\nPlease type: ```{cmd}```\nto setup the map automatically before loading the map preset."
    
    # Update the map effect on the map combatant
    neweffect = f"Size: {map_state['size']} ~ Background: {map_state['bg_image']} ~ Options: {map_state['mapoptions']}"
    map_combatant.add_effect('map', attacks=[{"attack":{"name":"map","automation":[{"type":"text","text":neweffect}],"_v":2}}])
    
    # Attach the updated map to the combatant
    place_combatants([c for c in combatants if autolib.isMonster(c) and c.name.lower() not in ['dm', 'map', 'lair']], True)
    place_combatants([c for c in combatants if not autolib.isMonster(c) and c.name.lower() not in ['dm', 'map', 'lair']], False)
    success, message = mapl.attach_map_to_combatant(map_state)
    
    if success:
        base_message = f"`{map_name}` map loaded successfully. Combat positions assigned.\n\n**Map-Art Courtesy of**:\n[2-Minute Tabletop](https://2minutetabletop.com/) under the [CC BY-NC 4.0 License](https://creativecommons.org/licenses/by-nc/4.0/)"
        if len(matches) > 1:
            other_matches = nl.join(matches[1:])
            base_message += f"\n\nYou may also be looking for: ```{other_matches}```"
        return True, base_message
    else:
        return False, message

def process_map_absentee_monster_turn(indexed_combatant, command_list):
    title = f'New monster detected: {indexed_combatant}'
    desc_text = f'This monster is not currently on the map, please place the monster\'s token on the map manually using: ```{pref}map -t {indexed_combatant}|C4```\nReplace `C4` to any location you like.'
    command_list.append(f"""{pref}embed -title "{title}" -desc "{desc_text}" -footer '{footer}'""")
    command_list.append(f'{pref}i n')

# Initialize overlays and descriptions
overlays = []
desc = []


###### TEST SUITES ######




###### TEST SUITES ######

# Main code execution starts here

if inp1.lower() in 'map':
    if inp2.lower() in 'list':
        # Generate the list of map options
        presets_embeds = presets.generate_list_embeds(footer)
        command_list += presets_embeds
        return command + nl.join(command_list)
    map_subtext = inp2
    success, message = load_specific_map(map_subtext)
    if success:
        # Generate the updated map image
        map_url = mapl.generate_map_image()
        command_list.append(f'{pref}embed -title "Map Updated" -desc "{message}" -image "{map_url}" -footer "{footer}"')
    else:
        command_list.append(f'{pref}embed -title "Map Setup Pending:" -desc "{message}" -footer "{footer}"')
    
    command += nl.join(command_list)
    return command

cname_list += [co.name for co in combatants]
monst_list = []
targets = []

for i in combatants:
    if i.monster_name and i not in monst_list and autolib.isMonster(i):
        monst_list.append(i.name)
        monst_name_list.append(i.monster_name)

targets = [x for x in cname_list if x not in monst_list]
if targets:
    for i in targets[:]:
        if i.casefold() in ['map', 'dm', 'lair']:
            targets.remove(i)
        elif autolib.isGhost(c, i):
            targets.remove(i)
if not targets:
    err(f'No playable characters found within Combat Initiative to target!\n\nPlease join the combat initiative using `{pref}i join` or remove ghost effect from characters')

map_combatant = mapl.mapPresent()
map_initialized = False

if map_combatant:
    for attack in map_combatant.attacks:
        if attack.name == 'map':
            map_initialized = True
            break

# Check if map is present, if not, add it to the command list
if not map_combatant:
    command_list.append(f'{pref}i add 0 Map -p 20')
    command_list.append(f'{pref}embed -title "Map Attached!" -desc "> *Note*: `{cmd}` now comes with a new update integrating OTFBM map-based combat with a full AI battle engine! If you\'d still like to use the old legacy version without maps support, worry not, it is still live on:\n> `{pref}autol`\n> (`l` stands for legacy)\n\n__**Suggested Actions**__:\n\nChoose from one of the many map presets:\n`{cmd} map list`\n\n### __Quick Setup Tips__\n**Small-size close-quarters map**:\n`{cmd} map pit`\n\n**Medium-size map**:\n`{cmd} map winter`\n`{cmd} map sky`\n`{cmd} map silent`\n\n**Large-size Map**:\n`{cmd} map light`\n\n**Load a random map preset:**\n`{cmd}`\n\n__Note__: Using any of the above quick setup commands will auto-magically add all players and monsters currently in the combat initiative to either end of the map.\n\n:warning: Make sure to add all the players and monsters to combat initiative before loading the map with one of the above commands for a seamless assignment of combat positions." -color <color> -footer "{footer}"')
    command += nl.join(command_list)
    return command
if not map_initialized:
    # Randomly select a map preset
    random_map_name, random_map_data = randchoice(list(presets.map_presets.items()))
    mapsize = random_map_data["size"]
    mapbg = random_map_data["image"]
    mapoptions = random_map_data["cell_pixel"]
    walls = objects = mapviewlocation = mapviewsize = ''

    map_combatant = mapl.mapPresent()

    if not map_combatant:
        missing_map_warning = f'Map init object missing!\n\nPlease add a map object to combat using:\n```{pref}i add 0 Map -p 20```'
        return f"""embed -title "Map Missing!" -desc "{missing_map_warning}" -footer "{footer}" """

    neweffect = f"Size: {mapsize} ~ Background: {mapbg} ~ Options: {mapoptions}"

    # Update the map effect on the map combatant
    map_combatant.add_effect('map', attacks=[{"attack":{"name":"map","automation":[{"type":"text","text":neweffect}],"_v":2}}])

    # Update map_state with the new size
    map_state["size"] = mapsize

    place_combatants([c for c in combatants if autolib.isMonster(c) and c.name.lower() not in ['dm', 'map', 'lair']], True)
    place_combatants([c for c in combatants if not autolib.isMonster(c) and c.name.lower() not in ['dm', 'map', 'lair']], False)
    bool_result, map_status = mapl.attach_map_to_combatant(map_state)
    if not bool_result:
        return f"""embed -title "Map Missing!" -desc "{map_status}" -footer "{footer}" """
    map_url = mapl.generate_map_image()
    command_list.append(f'{pref}embed -title "Map Initialized: {random_map_name.title()}" -desc "Combat positions assigned.\n\n**Map-Art Courtesy of**:\n[2-Minute Tabletop](https://2minutetabletop.com/) under the [CC BY-NC 4.0 License](https://creativecommons.org/licenses/by-nc/4.0/)" -image "{map_url}" -footer "{footer}"')


current_init = None if not c.current else c.current.name

if current_init is None:
    title = f'Booting up ancient artificial intelligences! :robot:'
    if monst_list:
        desc_text = f'\n:robot: _Auto-attack sequence initiated!_\n\nAutomating the following monsters:\n**{comma.join(monst_list)}**\n\n**Use `{cmd}` again now to automate all monsters in combat!**'
        command_list.append(f'{pref}i n')
    else:
        desc_text = f'_No monsters found in initiative!_\n\nThat\'s fine, feel free to add them any time and run `{cmd}` every time it\'s the monster\'s turn!'
    if not map_combatant:
        command_list.append(f'{pref}i add 0 Map -p 20')
    command_list.append(f"""{pref}embed -title "{title}" -desc "{desc_text}" -footer '{footer}'""")
    command += nl.join(command_list)
    return command
    
if current_init in monst_list and not autolib.hasMonsterGroup(c):
    indexed_cname_list = []
    curr_combatant = c.current
    
    map_url = mapl.generate_map_image(overlays)
    command_list.append(f'''{pref}embed -title "Monsters are deciding their actions..." -image "{map_url}" -footer "{footer}"''')
    
    if inp == 'once':
        # Implement the 'once' sub-command
        if current_init in monst_list:
            process_monster_turn(current_init, targets, c, out, overlays, desc, command_list)
            # Update map_state["combatants"] with 'out'
            map_state["combatants"] = out
            if overlays:
                map_url = mapl.generate_map_image(overlays)
                map_embed = f'{pref}embed -title "Updated Map" -desc "Monster movements displayed" -image "{map_url}" -footer "{footer}"'
                command_list.append(map_embed)
            command += nl.join(command_list)
            return command
        
    # Build the indexed list starting from current initiative
    # Sort the combatants by initiative (descending) and then by name
    combatants_in_order = c.combatants
    cname_list_sorted = [combatant.name for combatant in combatants_in_order]

    indexed_cname_list = cname_list_sorted[cname_list_sorted.index(current_init):] + cname_list_sorted[:cname_list_sorted.index(current_init)]

    if len(indexed_cname_list) > 4:
        indexed_cname_list = indexed_cname_list[:4]

    for indexed_combatant in indexed_cname_list:
        if len(command_list) > 12:
            title = f'Whoa! You\'re pushing the limits of Avrae right now!'
            desc_text = f'Unfortunately, this is the maximum number of attacks you can automate to prevent unnecessarily over-stressing Avrae!\n\n**But no worries, you can simply use `{cmd}` again now to repeat the cycle!**'
            while len(command_list) > 12:
                command_list.reverse()
                last_n = command_list.index(f'{pref}i n')
                command_list = command_list[last_n+1:]
                command_list.reverse()
            command_list.append(f'{pref}i n')
            command_list.append(f"""{pref}embed -title "{title}" -desc "{desc_text}" -footer '{footer}'""")
            command += nl.join(command_list)
            return command
        if indexed_combatant in monst_list:
            monster = c.get_combatant(indexed_combatant)    
            note = mapl.parse_note(monster.note)

            if not note or not 'location' in note:
                process_map_absentee_monster_turn(indexed_combatant, command_list)
            else:
                process_monster_turn(indexed_combatant, targets, c, out, overlays, desc, command_list)
                toggle_monster_color(monster, 'r')
        else:
            # Handle non-monster combatants
            if indexed_combatant.casefold() in ['map', 'dm', 'lair'] and c.get_combatant(indexed_combatant).init == 20:
                title = f'Automation Complete! Waiting on Lair Action :dragon:'
                desc_text = f'Use `{pref}i n` if there are no actions to take this round!'
            elif inp1.lower() in 'react':
                command_list.pop()
                title = f'Automation Complete! Pausing to allow player reaction! :mage:'
                desc_text = f'After taking any reaction use `{pref}i n`'
            else:
                title = f'Automation Complete! It\'s a player turn now! :mage:'
                desc_text = f'Waiting on **{indexed_combatant}** to play their turn!'
            command_list.append(f"""{pref}embed -title "{title}" -desc "{desc_text}" -footer '{footer}'""")
            break

    # Update map_state["combatants"] with 'out'
    map_state["combatants"] = out


    if overlays:
        map_url = mapl.generate_map_image(overlays)
        map_embed = f'{pref}embed -title "Monster Movement Summary" -desc "Monster movements so far:" -image "{map_url}" -footer "{footer}"'
        command_list.append(map_embed)

    command += nl.join(command_list)
    return command


# It's a player's turn
if current_init.casefold() in ['map', 'dm', 'lair'] and c.turn_num == 20:
    title = f'Waiting on Lair Action :dragon:'
    desc_text = f'Use `{pref}i n` if there are no actions to take this round!'
else:
    title = f'It\'s a player turn! :mage:'
    if not get_uvar('mapStates'):
        desc_text = f"""
Waiting on **{current_init}** to play their turn!

To move your player character on the map:

1. Ensure that you or the server you are in is subscribed to the `{pref}map` alias.
    - You can quickly add it as a personal alias using:
    ```
    {pref}alias subscribe https://avrae.io/dashboard/workshop/5f6a4623f4c89c324d6a5cd3
    ```

2. Move your character using the `{pref}move` alias: (companion alias to `{pref}map`)
    - For example:
   ```
   {pref}move C4
   ```
   (Replace "C4" with the cell address of your desired location on the map.)
"""
    else:
        desc_text = f"Waiting on **{current_init}** to play their turn!"

return f'''embed -title "{title}" -desc "{desc_text}" -footer "{footer}"'''
</drac2>