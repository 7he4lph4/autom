<drac2>
#auto
pref, al = ctx.prefix, ctx.alias
cmd = pref+al
null, nl, comma = '', '\n', ','
args = argparse(&ARGS&)

cname_list, command_list, combatant_mismatch = [],[],[]
multiattack, spell_viable, counter = False, False, 0

raw_inp = "&*&"
inp = "&*&".lower().replace('"', '')
inp1 = "&1&"
inp2 = "&2&"
inp3 = "&3&"

using(
    autolib="ec14bc6e-81e4-4df7-86e9-5d64ed2fa9b7",
    core="49f5f503-1c00-4f24-ba43-92e65c2c2fb6",
    presets = "c14e4526-4acb-4964-8ba9-f6861617ffdf",
    mapl = "faa1ca51-5c75-401c-be46-8650472e68f2",
    mobl = "a7863890-e522-4116-a79f-2fb764a83f77",
    targl = "f8369cc0-8ab0-42a5-8dfd-4ab7f34c0e61"
)

command = f"""multiline{nl}"""
footer = f'{cmd} help | made by @alpha983'

if inp1.lower() in ['m', 'map'] and inp2.lower() == 'list':
    return command + nl.join(presets.generate_list_embeds(footer))

c = combat()

help_title = f'{name} needs help breathing life into these monsters!'
help_text = f"""How to use `{cmd}`:

- Start combat initiative with `{pref}i begin`, and add all the necessary players and monsters
    - *Pro Tip*: use the [Encounter Generator](https://avrae.io/dashboard/workshop/654fbc27ac7cd2bc90723133/) alias to quickly setup a balanced encounter for any party
- Once all monsters and players are added, use `{cmd}` to auto-magically add the *Map* combatant
- Use `{cmd} map list` to see all preset maps
- Use `{cmd} map <map name>` to load one of the preset maps
- Or, simply use `{cmd}` again to randomly pick one of the preset maps
    - (ideally you can keep spamming `{cmd}` after adding all players and monsters to combat initiative)
- Use `{cmd}` to automate all monsters until the next player in combat initiative

*Note*: If you'd like to keep using the old alias without maps support, you can use:
`{pref}autol`
(`l` stands for legacy)

This alias relies on the OTFBM backend service for map generation. They have server costs to cover, so please consider supporting their work through their [Patreon page](https://www.patreon.com/otfbm) if you're able

You can also support the development of this alias on [Ko-fi](https://ko-fi.com/hedy4u)!
"""
title = help_title
desc_text = help_text
if not c or inp == 'help' or inp == '?':
    title = f'{cmd} works best when used with a combat initiative full of player characters and monsters!'
    desc = 'Please start initiative and add your players and  monsters.'
    return f'embed -title "{title}" -desc "{desc_text}" -footer "{footer}"'
    

# INITIALIZING COMBAT AND MAP


if inp1.lower() == 'lair':
    command_list.append(f'{pref}i add 0 Lair -p 20')
    command_list.append(f'''{pref}embed -title "A Lair Object has been added!" -desc "A Lair object was added at Initiative 20 to run monsters' Lair Actions." -color <color> -footer "{footer}"''')
    return command + nl.join(command_list)

combatants = c.combatants
combatant_list, party_list, monster_list = targl.get_target_lists()

party_names = [p.name for p in party_list]
monster_names, monster_types = [], []
for mon in monster_list:
    monster_names.append(mon.name)
    monster_types.append(mon.monster_name)

# Map-related variables
alph = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
size_map = {
    'Tiny': ('T', 1),
    'Small': ('S', 1),
    'Medium': ('M', 1),
    'Large': ('L', 2),
    'Huge': ('H', 3),
    'Gargantuan': ('G', 4)
}
size_dict = {"T": "Tiny", "S": "Small", "M": "Medium", "L": "Large", "H": "Huge", "G": "Gargantuan"}
map_base_url = get("otfbm_base_url", "http://otfbm.io/")
map_state = {"current_map": None, "size": None, "bg_image": None}
mapsize = get("mapSize", "20x20")
out = {}

map_combatant = mapl.mapPresent()
map_info, map_attach = mapl.get_map_info()
if not map_attach:
    map_attach = (
        map_combatant if map_combatant
        else combat().me if combat().me else party_list[0] if 0 < len(party_list) else None
    )
    if not map_attach:
        desc = f"""No combatant found to attach the map to!
        \nIf you are fighting a monster with Lair Actions, add a Lair object with:
        `{cmd} lair`\n\nOtherwise, a player must join the combat initiative using `{pref}i join`
        """
        return f'embed -title "Map Setup Pending:" -desc "{desc}" -color <color> -footer "{footer}"'
    map_attach.add_effect("map", attacks=[{"attack": {"name":"map", "automation": [{"type":"text", "text":""}], "_v":2,}}])
    desc = f"""
> *Note*: `{cmd}` now comes with a new update integrating OTFBM map-based combat with a full AI battle engine! If you'd still like to use the old legacy version without maps support, worry not, it is still live on:
> `{pref}autol` (`l` stands for legacy)
\n__**Suggested Actions**__:
\nIf you are fighting a monster with Lair Actions, add a Lair object with:
`{cmd} lair`
\nChoose from one of the many map presets:\n`{cmd} map list`
### __Quick Setup Tips__
**Small-size close-quarters map**:\n`{cmd} map pit`
\n**Medium-size map**:\n`{cmd} map winter`\n`{cmd} map sky`\n`{cmd} map silent`
\n**Large-size Map**:\n`{cmd} map light`
\n**Load a random map preset:**\n`{cmd}`
\n__Note__: Using any of the above quick setup commands will auto-magically add all players and monsters currently in the combat initiative to either end of the map.
\n:warning: Make sure to add all the players and monsters to combat initiative before loading the map with one of the above commands for a seamless assignment of combat positions.
    """
    return f'embed -title "Map Settings attached to {map_attach.name}!" -desc "{desc}" -color <color> -footer "{footer}"'
        
occupied_positions = set()
map_combatants = mapl.get_all_map_combatants()
placed, unplaced = mapl.get_placed_combatants()

def place_combatants():
    size_groups = {"G": [], "H": [], "L": [], "M": []}
    for upc, data in unplaced.items():
        size = data.get("size")
        if not size:
            size = "M"
            if upc.monster_name:
                mon_data = mobl.get_monster_data(upc.monster_name, 'meta')
                size = mon_data.split()[0] if mon_data else size
            data.update({"size": size, "size_mod": mapl.get_size_mod(size)})
        (size_groups[size[0]] if size[0] in "GHL" else size_groups["M"]).append(upc)
       
    width, height = mapl.parse_mapsize(map_state.get("size"))
    
    player_side = 0
    players_x = [placed[p]["pos"][0] for p in placed if not autolib.isMonster(p)]
    if 0 < len(players_x):
        player_side = round((sum(players_x) / len(players_x)) / (width - 1))
    for sg, unplaced_c in size_groups.items():
        if len(unplaced_c) < 1:
            continue
        size_mod = mapl.get_size_mod(sg)
        occupied_grid = {x: [] for x in range(0, width - size_mod)}
        for p, data in placed.items():
            mapl.update_occupied(occupied_grid, size_mod, data, width, height)
        sides = {
            0: range(width // 2 - size_mod - 1, -1, -1),
            1: range(width // 2, width - size_mod)
        }
        y_range = list(range(1, height - size_mod + 1))
        for upc in unplaced_c:
            is_monster = autolib.isMonster(upc)
            side = player_side if not is_monster else 1 - player_side
            side_cols = [x for x in sides[side] if x in occupied_grid]
            if not side_cols:
                side_cols = [x for x in sides[1 - side] if x in occupied_grid][0:1]
                if not side_cols:
                    continue
            x = randchoice(side_cols)
            y = randchoice([ry for ry in y_range if ry not in occupied_grid[x]])
            
            placed[upc] = {"pos": (x, y), "size": sg, "size_mod": size_mod}
            mapl.update_occupied(occupied_grid, size_mod, placed[upc], width, height)
            
            location = mapl.coords_to_loc([x, y])
            out[upc.name] = out.get(upc.name, {})
            out[upc.name]['location'] = location
            out[upc.name]['size'] = sg
            out[upc.name]['color'] = 'r' if is_monster else 'b'
            
            upc.set_note(
                f"Location: {location} | Color: {out[upc.name]['color']} | Size: {sg} ({size_dict[sg]})"
            )
            map_state["combatants"] = map_state.get("combatants", {})
            map_state["combatants"].update(out)
            unplaced.pop(upc)
        # if unplaced:
        #     err(f"Could not place {combatant.name} on the map without overlapping.")

def load_specific_map(map_name):
    map_name, map_data, matches = presets.find_map_by_subtext(map_name)
    error_base = '-title "Map Setup Pending:" -desc '
    if not matches:
        return error_base + f'''"No maps found matching '{map_name}'. Use `{cmd} map list` to see available maps."'''
    
    # Update map_state with new map data
    map_state["current_map"] = map_name
    map_state["size"] = map_data["size"]
    map_state["mapoptions"] = map_data["cell_pixel"]
    map_state["bg_image"] = map_data["image"]
    
    # Update the map effect on the map attach
    neweffect = f"Size: {map_state['size']} ~ Background: {map_state['bg_image']} ~ Options: {map_state['mapoptions']}"
    map_attach.remove_effect('map')
    map_attach.add_effect('map', attacks=[{"attack":{"name":"map","automation":[{"type":"text","text":neweffect}],"_v":2}}])
    
    # Attach the updated map to the combatant
    place_combatants()
    
    base_message = f"`{map_name}` map loaded successfully. Combat positions assigned.\n\n**Map-Art Courtesy of**:\n[2-Minute Tabletop](https://2minutetabletop.com/) under the [CC BY-NC 4.0 License](https://creativecommons.org/licenses/by-nc/4.0/)"
    if len(matches) > 1:
        other_matches = nl.join(matches[1:])
        base_message += f"\n\nYou may also be looking for: ```{other_matches}```"
    map_url = mapl.generate_map_image()
    return f'-title "Map Updated" -desc "{base_message}" -image "{map_url}"'

if inp1.lower() in ['m', 'map']:
    return f'embed {load_specific_map(inp2)} -footer "{footer}"'
elif not map_info:
    message = load_specific_map(randchoice(list(presets.map_presets.keys())))
    return f'embed {message} -footer "{footer}"'
else:
    map_state["size"] = map_info["size"]
    map_state["mapoptions"] = map_info["options"]
    map_state["bg_image"] = map_info["background"]

if unplaced:
    place_combatants()
    command_list.append(f'{pref}embed -title "Map Setup Complete!" -desc "All combatants have been placed on the map." -footer "{footer}"')

# MAP INITIALIZATION COMPLETE


def find_best_target(monster, target_names, max_surrounding=2):
    if monster.stats.intelligence < 10:
        return target_names[randint(len(target_names))]
    
    targets = [c.get_combatant(name) for name in target_names if c.get_combatant(name)]
    target_hp = [(t, t.hp) for t in targets if t.hp is not None and t.hp > 0]
    
    if not target_hp:
        return target_names[randint(len(target_names))]
    
    def count_surrounding_monsters(target):
        target_location = get_combatant_location(target)
        if not target_location:
            return 0, False
        surrounding_cells = get_surrounding_positions(target_location)
        monster_count = 0
        large_monster_present = False
        for cell in surrounding_cells:
            monster = get_monster_at_location(cell, c)
            if monster:
                monster_count += 1
                if is_large_monster(monster):
                    large_monster_present = True
        return monster_count, large_monster_present
    
    def get_combatant_location(combatant):
        if combatant.note:
            note_parts = combatant.note.split('|')
            for part in note_parts:
                if part.strip().lower().startswith('location:'):
                    return part.split(':')[1].strip()
        return None
    
    def get_monster_at_location(cell, combat):
        for combatant in combat.combatants:
            if autolib.isMonster(combatant) and get_combatant_location(combatant) == cell:
                return combatant
        return None
    
    def is_large_monster(monster):
        if monster.note:
            note_parts = monster.note.split('|')
            for part in note_parts:
                if part.strip().lower().startswith('size:'):
                    size = part.split(':')[1].strip().lower()
                    return size in ['l', 'h', 'g', 'large', 'huge', 'gargantuan']
        return False
    
    # Sort targets by HP and intelligence level
    if monster.stats.intelligence >= 17:
        sorted_targets = core.sorted(target_hp, key=lambda x: x[1])
    else:
        # Weighted random selection favoring lower HP targets
        weights = [max(1, 100 - t[1]) for t in target_hp]
        sorted_targets = [t for t, _ in core.sorted(core.zip(target_hp, weights), key=lambda x: x[1], reverse=True)]
    
    for target, _ in sorted_targets:
        monster_count, large_monster_present = count_surrounding_monsters(target)
        if monster_count < max_surrounding and not large_monster_present:
            return target.name
    
    # If all preferred targets are surrounded or near large monsters, choose the least surrounded one without a large monster
    valid_targets = [t for t in sorted_targets if not count_surrounding_monsters(t[0])[1]]
    if valid_targets:
        return min(valid_targets, key=lambda x: count_surrounding_monsters(x[0])[0])[0].name
    
    # If all targets have large monsters nearby, choose a random target from the valid ones (those with HP > 0)
    return randchoice([t.name for t, _ in target_hp]) if target_hp else None

def get_map_size():
    mapsize = "10x10"  # Default map size
    maxSize = 99

    # Check if there's a map combatant with size information
    for combatant in c.combatants:
        for attack in combatant.attacks:
            if attack.name == 'map':
                mapinfo = attack.raw.automation[-1].text
                mapinfo = mapinfo.split(' ~ ')
                mapinfo = {x[0].lower():x[1] for x in [item.split(': ') for item in mapinfo]}
                if mapinfo.get('size'):
                    mapsize = mapinfo.get('size')
                break
        if mapsize != "10x10":
            break

    # Parse the mapsize
    if mapsize != "JSON":
        if ":" in mapsize:
            mapsize = mapsize.split(':')[1]
        if mapsize[0].isdigit():
            mapSplitX, mapSplitY = mapsize.lower().split('x')
            mapX = min(int(mapSplitX) if mapSplitX.isdigit() else 1, maxSize)
            mapY = min(int(mapSplitY) if mapSplitY.isdigit() else 1, maxSize)
        else:
            alphx = []
            for index in range(maxSize):
                letter = ""
                if index // 26:
                    letter = alphx[(index // 26) - 1]
                letter += alphx[index % 26]
                alphx.append(letter)
            mapX = alphx.index(''.join(x.upper() for x in mapsize if x.isalpha())) + 1
            mapY = int(''.join(y for y in mapsize if y.isdigit()))
    else:
        mapX = mapY = 10  # Default size for JSON

    return mapX, mapY

def find_best_aoe_position(monster, aoe_attack, target_names):
    best_position = None
    max_targets = 0
    monster_map_data = mapl.parse_note(monster.note)
    monster_location = monster_map_data.get('location', None)
    if not monster_location:
        return None

    mapX, mapY = get_map_size()

    # Generate positions in the monster's line of sight/direction
    # For simplicity, we'll consider positions in front of the monster
    # Assuming the monster is facing towards the majority of targets

    # Find the center position of all targets to determine general direction
    target_positions = []
    for target_name in target_names:
        target = c.get_combatant(target_name)
        if target:
            target_map_data = mapl.parse_note(target.note)
            target_location = target_map_data.get('location', None)
            if target_location:
                coords = mapl.loc_to_coords(target_location)
                target_positions.append(coords)

    if not target_positions:
        return None

    # Calculate average position of targets
    avg_x = sum(pos[0] for pos in target_positions) / len(target_positions)
    avg_y = sum(pos[1] for pos in target_positions) / len(target_positions)
    direction_vector = [avg_x - mapl.loc_to_coords(monster_location)[0], avg_y - mapl.loc_to_coords(monster_location)[1]]

    # Normalize direction vector
    length = sqrt(direction_vector[0] ** 2 + direction_vector[1] ** 2)
    if length == 0:
        direction_vector = [0, 1]  # Default direction
    else:
        direction_vector = [direction_vector[0] / length, direction_vector[1] / length]

    # Check positions in the direction the monster is facing
    for distance in range(1, max(mapX, mapY)):
        x = mapl.loc_to_coords(monster_location)[0] + int(direction_vector[0] * distance)
        y = mapl.loc_to_coords(monster_location)[1] + int(direction_vector[1] * distance)
        if x < 0 or y < 1 or x >= len(alph) or y > mapY:
            break
        position = f"{alph[x]}{y}"
        affected_targets = count_affected_targets(position, aoe_attack, target_names)
        if affected_targets > max_targets:
            max_targets = affected_targets
            best_position = position

    return best_position

def count_affected_targets(position, aoe_attack, targets):
    affected = 0

    for target in targets:
        target_map_data = mapl.parse_note(c.get_combatant(target).note)
        target_location = target_map_data.get('location', None)
        if target_location and is_in_aoe(position, target_location, aoe_attack):
            affected += 1
    return affected

def is_in_aoe(origin, target, aoe_attack):
    ox, oy = alph.index(origin[0]), int(origin[1:])
    tx, ty = alph.index(target[0]), int(target[1:])
    dx, dy = abs(tx - ox), abs(ty - oy)
    distance = max(dx, dy) * 5  # Assuming 5ft per square

    if aoe_attack['shape'] in ['cone', 'sphere', 'radius']:
        return distance <= aoe_attack['size']
    elif aoe_attack['shape'] == 'line':
        return (dx == 0 or dy == 0 or dx == dy) and distance <= aoe_attack['size']
    elif aoe_attack['shape'] in ['cube', 'cylinder']:
        return dx <= aoe_attack['size'] // 5 and dy <= aoe_attack['size'] // 5

    return False

def distance(pos1, pos2):
    x1, y1 = alph.index(pos1[0].upper()), int(pos1[1:])
    x2, y2 = alph.index(pos2[0].upper()), int(pos2[1:])
    dx = abs(x2 - x1)
    dy = abs(y2 - y1)
    
    # D&D 5e uses a simplified diagonal movement rule
    # where every other diagonal counts as 10 feet instead of 5
    diagonals = min(dx, dy)
    straight = abs(dx - dy)
    
    return (diagonals * 5) + (straight * 5)

def draw_aoe_overlay(monster, aoe_attack, position, targets):

    shapeDict = [{"type": "circle",       "name":"c",  "num": [3], "args": ("size", "color", "loc")},
               {"type": "circletop",    "name":"ct", "num": [3], "args": ("size", "color", "loc")},
               {"type": "circlecorner", "name":"co", "num": [3], "args": ("size", "color", "loc")},
               {"type": "cone",         "name":"t",  "num": [4], "args": ("size", "color", "loc", "eloc")},
               {"type": "line",         "name":"l",  "num": [5], "args": ("size", "width", "color", "loc", "eloc")},
               {"type": "arrow",        "name":"a",  "num": [3], "args": ("color", "loc", "eloc")},
               {"type": "square",       "name":"s",  "num": [3,4], "args": ("size", "color", "loc", "eloc")},
               {"type": "squaretop",    "name":"st", "num": [3,4], "args": ("size", "color", "loc", "eloc")}]

    color = 'r'  # Default color for AoE
    shape = aoe_attack['shape']
    size = aoe_attack.get('size', 10)
    
    # Create a dictionary mapping shape names to their short codes
    shape_to_code = {item['type']: item['name'] for item in shapeDict}
    
    if shape in ['sphere', 'radius', 'cube', 'cylinder']:
        shape_code = shape_to_code['circle' if shape in ['sphere', 'radius'] else 'square']
        return f"{shape_code}{size}{color}{position}"
    
    if shape in ['cone', 'line']:
        nearest_target = min(targets, key=lambda t: distance(position, mapl.parse_note(c.get_combatant(t).note).get('location', 'A1')))
        nearest_pos = mapl.parse_note(c.get_combatant(nearest_target).note).get('location', 'A1')
        shape_code = shape_to_code[shape]
        return f"{shape_code}{size},{aoe_attack.get('width', size) if shape == 'line' else ''}{color}{position}{nearest_pos}".rstrip(',')
    
    return None

def find_adjacent_position(monster_location, target_position):
    mx, my = alph.index(monster_location[0]), int(monster_location[1:])
    tx, ty = alph.index(target_position[0]), int(target_position[1:])
    
    adjacent_positions = [
        (mx-1, my), (mx+1, my), (mx, my-1), (mx, my+1),
        (mx-1, my-1), (mx-1, my+1), (mx+1, my-1), (mx+1, my+1)
    ]
    
    closest_position = min(adjacent_positions, key=lambda p: ((p[0]-tx)**2 + (p[1]-ty)**2))
    return f"{alph[closest_position[0]]}{closest_position[1]}"

def get_targets_in_aoe(monster_location, aoe_attack, target_names):
    affected_targets = []
    for target_name in target_names:
        target = c.get_combatant(target_name)
        if target:
            target_map_data = mapl.parse_note(target.note)
            target_location = target_map_data.get('location', None)
            if target_location and is_in_aoe(monster_location, target_location, aoe_attack):
                affected_targets.append(target_name)
    return affected_targets

def move_towards(start, end, distance, occupied_positions):
    start_pos = mapl.loc_to_coords(start)
    end_pos = mapl.loc_to_coords(end)
    total_distance = mapl.distance(start_pos, end_pos) * 5
    dxy = mapl.subtract_coords(end_pos, start_pos)
    ratio = min(distance / total_distance, 1) if 0 < total_distance else 0
    move_coords = mapl.add_coords(start_pos, mapl.scale_coords(dxy, ratio))
    new_location = mapl.coords_to_loc(move_coords)
    # Check if the new location is occupied
    if new_location in occupied_positions:
        new_location = find_nearest_unoccupied_position(start, end, occupied_positions)
    
    # Calculate actual movement for the arrow
    new_pos = mapl.loc_to_coords(new_location)
    distanceT = round(mapl.distance(start_pos, new_pos)) * 5
    
    # Generate arrow overlay with correct syntax
    color = 'r' # Use red color for the arrow
    arrow = f"*a{distanceT}{color}{start}{new_location}"
    
    return new_location, arrow

def create_arrow_overlay(start_location, end_location):
    start_pos = mapl.loc_to_coords(start_location)
    end_pos = mapl.loc_to_coords(end_location)
    distanceT = round(mapl.distance(start_pos, end_pos)) * 5
    
    # Generate arrow overlay with correct syntax
    colr = 'r' # Use red color for the arrow
    arrow = f"*a{distanceT}{colr}{start_location}{end_location}"
    return arrow

def update_monster_position(monster, new_location):
    # Parse the current note
    note_data = mapl.parse_note(monster.note)
    old_location = note_data.get('location', None)
    size_letter = note_data.get('size', 'M')
    size_map = {'T': 1, 'S': 1, 'M': 1, 'L': 2, 'H': 3, 'G': 4}
    mon_size_grid = size_map.get(size_letter.upper(), 1)

    # Remove old positions from occupied_positions
    if old_location:
        old_positions = get_occupied_positions(old_location, mon_size_grid)
        occupied_positions.difference_update(old_positions)

    # Update the location
    note_data['location'] = new_location

    # Use the update_combatant_note function to set the new note
    mapl.update_combatant_note(monster, **note_data)

    # Update the out dictionary
    out[monster.name] = out.get(monster.name, {})
    out[monster.name]['location'] = new_location

    # Add new positions to occupied_positions
    new_positions = get_occupied_positions(new_location, mon_size_grid)
    occupied_positions.update(new_positions)

def get_occupied_positions(location, size_grid):
    """
    Given a location (e.g., 'E5') and size in grid cells, return a set of occupied positions.
    """
    pos = mapl.loc_to_coords(location)
    positions = set()
    for dx in range(size_grid):
        for dy in range(size_grid):
            positions.add((pos[0] + dx, pos[1] + dy))
    return positions

def find_unoccupied_positions_near_target(target_location, monster_size_grid, occupied_positions, map_width, map_height):
    # Get positions occupied by target
    target_size_grid = 1  # Assume target is size 1 for now
    target_pos = mapl.loc_to_coords(target_location)
    target_positions = mapl.box(target_pos, target_size_grid)
    """target_positions = get_occupied_positions(target_location, target_size_grid)
    Get all adjacent positions to the target's occupied positions
    adjacent_positions = set()
    for pos in target_positions:
        x, y = pos
        for dx in range(-monster_size_grid, monster_size_grid + 1):
            for dy in range(-monster_size_grid, monster_size_grid + 1):
                if dx == 0 and dy == 0:
                    continue
                adj_x = x + dx
                adj_y = y + dy
                # Check bounds
                if 0 <= adj_x < len(alph) and 1 <= adj_y <= map_height:
                    adjacent_positions.add((adj_x, adj_y))"""
    adjacent_positions = mapl.melee_box(monster_size_grid, target_pos, target_size_grid)

    # Now, for each adjacent position, check if the monster can occupy it
    available_positions = []
    for pos in adjacent_positions:
        x, y = pos
        # Check if monster can occupy positions from (x, y) to (x + size - 1, y + size - 1)
        can_occupy = True
        for dx in range(monster_size_grid):
            for dy in range(monster_size_grid):
                check_pos = (x + dx, y + dy)
                if check_pos in occupied_positions:
                    can_occupy = False
                    break
                # Check bounds
                if check_pos[0] >= len(alph) or check_pos[1] > map_height:
                    can_occupy = False
                    break
            if not can_occupy:
                break
        if can_occupy:
            available_positions.append((x, y))
    return available_positions

def choose_closest_position_coords(monster_location, positions):
    monster_coords = mapl.loc_to_coords(monster_location)

    # Calculate distances to each position
    distances = [(mapl.distance(monster_coords, pos), pos) for pos in positions]
    distances.sort()
    return distances[0][1] if distances else None

def get_surrounding_positions(center):
    x = alph.index(''.join(core.filter(str.isalpha, center)).upper())
    y = int(''.join(core.filter(str.isdigit, center)))
    surrounding = [
        (x-1, y-1), (x, y-1), (x+1, y-1),
        (x-1, y),             (x+1, y),
        (x-1, y+1), (x, y+1), (x+1, y+1)
    ]
    return [f"{alph[pos[0]]}{pos[1]}" for pos in surrounding if 0 <= pos[0] < len(alph) and 1 <= pos[1] <= 20]

def find_nearest_unoccupied_position(start, end, occupied_positions):
    end_pos = mapl.loc_to_coords(end)
    end_surrounding = [mapl.coords_to_loc(p) for p in mapl.out_box(end_pos, 0)]
    available_positions = [pos for pos in end_surrounding if pos not in occupied_positions]
    
    if not available_positions:
        return start  # No available positions, stay at current position
    
    # Find the nearest available position
    start_pos = mapl.loc_to_coords(start)
    return min(available_positions, key=lambda pos: mapl.distance(start_pos, mapl.loc_to_coords(pos)) * 5)

def get_attack_reach(attack_str):
    attack_str = attack_str.lower()
    if 'reach' in attack_str:
        words = attack_str.split()
        for i, word in enumerate(words):
            if word == 'reach' and i + 1 < len(words):
                reach = ''.join(core.filter(str.isdigit, words[i+1]))
                if reach:
                    return int(reach)
    return 8  # Default melee reach

def get_max_attack_reach(attacks):
    max_reach = 8
    for attack in attacks:
        reach = get_attack_reach(str(attack["automation"]))
        if reach > max_reach:
            max_reach = reach
    return max_reach

def get_spell_range(spell_name):
    spell_data = load_json(get_gvar('00d6334d-af6c-46ac-b810-752465e0ad33'))
    spell_name = spell_name.strip('"')  # Remove quotes if present
    for spell in spell_data:
        if spell['name'].lower() == spell_name.lower():
            range_str = spell['range']
            # Extract the numeric value from the range string
            range_value = ''.join(core.filter(str.isdigit, range_str))
            return int(range_value) if range_value else 30  # Default to 30 if no numeric value found
    return 30  # Default range if spell not found

def process_monster_turn(indexed_combatant, targets, c, out, overlays, desc, command_list):
    monster = c.get_combatant(indexed_combatant)
    if not monster:
        desc.append(f"Could not find combatant: {indexed_combatant}")
        return

    monster_name = monster.monster_name
    curr_hp = monster.hp
    
    # Fetch monster data if not already stored
    if not mobl.get_stored_monster_data(monster_name):
        mobl.fetch_and_store_monster_data()

    # Check if the monster is already dead at the start of its turn
    if monster.hp <= 0:
        remove_dead_monster(c, monster, out, desc)
        map_url = mapl.generate_map_image(overlays)
        command_list.append(f'{pref}embed -title "Skipping dead monster: {monster.name}" -desc "{monster.name} has been defeated and removed from the map. Its turn will be skipped." -image "{map_url}" -footer "{footer}"')
        command_list.append(f'{pref}i n')  # Skip to next turn
        return

    # Get location from note
    monster_map_data = mapl.parse_note(monster.note)
    monster_location = monster_map_data.get('location', None)
    monster_size_mod = mapl.get_size_mod(monster_map_data.get('size', 'M'))

    # Check if map is present
    if map_attach and monster_location:
        # Get occupied positions to avoid collisions
        occupied_positions = mapl.get_occupied_coords(monster.name)
        

        ### AoE ###
        aoe_attacks = mobl.get_aoe_attacks(monster.name)

        if aoe_attacks:
            aoe_attack = randchoice(aoe_attacks)

            # Create a list of all potential targets (excluding the monster itself)
            all_combatants = [c.name for c in c.combatants if c.name.lower() not in ['map', 'dm', 'lair']]
            potential_targets = [name for name in all_combatants if name != monster.name]

            # Find the best position for the AoE attack
            best_position = find_best_aoe_position(monster, aoe_attack, potential_targets)

            if best_position:
                # Calculate the distance to the best position
                start_pos = mapl.loc_to_coords(monster_location)
                end_pos = mapl.loc_to_coords(best_position)
                distance_to_position = mapl.distance(start_pos, end_pos) * 5

                monster_speed = mobl.get_monster_speed(monster_name)[0]

                # Move the monster if needed
                if distance_to_position > 0:
                    move_distance = min(monster_speed, distance_to_position)
                    new_location, arrow = move_towards(monster_location, best_position, move_distance, occupied_positions)
                    update_monster_position(monster, new_location)
                    occupied_positions.add(new_location)
                    if arrow:
                        overlays.append(arrow)
                    monster_location = new_location
                    desc.append(f"{indexed_combatant} moves {int(move_distance)} ft. towards the optimal position for its AoE attack.")

                    # Display the updated map after movement
                    map_state["combatants"] = out
                    map_url = mapl.generate_map_image(overlays)
                    command_list.append(f'{pref}embed -title "Monster Movement: {monster.name}" -desc "{desc[-1]}" -image "{map_url}" -footer "{footer}"')

                # Adjust the AoE position for cone and line attacks
                if aoe_attack['shape'] in ['cone', 'line']:
                    best_position = find_adjacent_position(monster_location, best_position)

                # Create and add the AoE overlay
                overlay = draw_aoe_overlay(monster, aoe_attack, best_position, potential_targets)
                if overlay:
                    overlays.append(f"*{overlay}")
                    desc.append(f"{monster.name} uses {aoe_attack['name']} starting at {monster_location} towards {best_position}")

                    # Display the map with the AoE overlay
                    map_url = mapl.generate_map_image(overlays)
                    command_list.append(f'{pref}embed -title "AoE Attack: {monster.name}" -desc "{desc[-1]}" -image "{map_url}" -footer "{footer}"')

                    # Find targets within the AoE
                    affected_targets = get_targets_in_aoe(monster_location, aoe_attack, potential_targets)

                    # Add the attack command targeting all affected combatants
                    if affected_targets:
                        target_string = " -t ".join(affected_targets)
                        command_list.append(f'{ctx.prefix}i a "{aoe_attack["name"]}" -t {target_string} -phrase ":robot: _Triggered by auto monster AI_"')
                    else:
                        desc.append(f"No targets were caught in the AoE of {aoe_attack['name']}.")

                    command_list.append(f'{ctx.prefix}i n')
                    return
        ### AoE ###

        chosen_target = find_best_target(monster, targets)
        target_combatant = c.get_combatant(chosen_target)
        if not target_combatant:
            desc.append(f"Could not find target: {chosen_target}")
            return

        target_map_data = mapl.parse_note(target_combatant.note)
        target_location = target_map_data.get('location', None)
        target_size_mod = mapl.get_size_mod(target_map_data.get('size', 'M'))

        if target_location:
            start_pos = mapl.loc_to_coords(monster_location)
            monster_box = mapl.box(start_pos, monster_size_mod)
            
            target_pos = mapl.loc_to_coords(target_location)
            target_box = mapl.box(target_pos, target_size_mod)
            
            monster_speed = mobl.get_monster_speed(monster_name)[0]
            max_attack_reach = get_max_attack_reach(monster.attacks)
            nearest_dist, monster_nearest, target_nearest = mapl.get_nearest_coords(
                monster_box, target_box
            )
            distance = nearest_dist * 5
            
            # Check if the monster is a spellcaster
            spell_monst = monster.spellbook.caster_level

            # Before moving, display the map
            map_state["combatants"] = out
            toggle_monster_color(monster, 'p')
            # map_url = mapl.generate_map_image(overlays)
            # command_list.append(f'''{pref}embed -title "Monsters are deciding their actions..." -image "{map_url}" -footer "{footer}"''')

            monster_size_mod = mapl.get_size_mod(monster_map_data.get('size', 'M'))
            occupied_positions = mapl.get_occupied_coords(monster.name, monster_size_mod)
            # occupants = mapl.get_occupants(monster.name, monster_size_mod)
            # occupied_positions = set(out[name].get('location') for name in out if 'location' in out[name])
            
            # Spellcasting logic
            if spell_monst:
                spell_data = load_json(get_gvar("a1e23cdf-0510-480d-a616-59e2c46780ac"))
                spell_list = [spell.name for spell in monster.spellbook.spells]
                spell_viable = False
                chosen_spell = None
                chosen_spell_level = 0

                # Create a list of viable spells
                viable_spells = []
                for spell in spell_list:
                    if spell in spell_data:
                        spell_level = spell_data[spell]
                        if monster.spellbook.can_cast(spell, spell_level):
                            viable_spells.append((spell, spell_level))

                # If there are viable spells, choose one randomly
                if viable_spells:
                    chosen_spell, chosen_spell_level = randchoice(viable_spells)
                    spell_viable = True

                if spell_viable:
                    # Check if the monster needs to move to cast the spell
                    spell_range = get_spell_range(chosen_spell)
                    ideal_distance = max(30, spell_range - 30)  # Stay 30 ft away from max range if possible
                    
                    if distance != ideal_distance:
                        move_distance = min(monster_speed, abs(distance - ideal_distance))
                        movement_direction = "towards" if distance > ideal_distance else "away from"
                        new_location, arrow = move_towards(monster_location, target_location, move_distance, occupied_positions)
                        update_monster_position(monster, new_location)
                        occupied_positions.add(new_location)
                        if arrow:
                            overlays.append(arrow)
                        monster_location = new_location
                        desc.append(f"{indexed_combatant} moves {int(move_distance)} ft. {movement_direction} {chosen_target} for a better vantage point.")
                        
                        # After movement, display the updated map
                        map_state["combatants"] = out
                        map_url = mapl.generate_map_image(overlays)
                        command_list.append(f'{pref}embed -title "Monster Movement: {monster.name}" -desc "{desc[-1]}" -image "{map_url}" -footer "{footer}"')
                    else:
                        desc.append(f"{indexed_combatant} holds position, already at an ideal vantage point.")
                    
                    # Cast the spell
                    command_list.append(f'{pref}i cast "{chosen_spell}" -t {chosen_target} -l {chosen_spell_level} -phrase ":robot: _Triggered by auto monster AI_"')
                    desc.append(f"{indexed_combatant} casts {chosen_spell} at {chosen_target}.")
                    command_list.append(f'{pref}i n')
                    return

            # Melee combat logic (if not a spellcaster or out of spell slots)
            if max_attack_reach < distance:
                move_distance = min(monster_speed, distance - max_attack_reach)
                if move_distance < distance - max_attack_reach:                  
                    # Monster needs to dash
                    move_distance = min(monster_speed * 2, distance - max_attack_reach)
                    map_size = mapl.parse_mapsize(mapl.get_map_info()[0].get("size"))
                    # circle = mapl.circle(start_pos, (monster_speed * 2) / 5, bounds=[0, 1, map_size[0], map_size[1]])
                    # for oco, oco_info in occupants.items():
                    #   circle = [cc for cc in circle if cc not in oco_info.box] #+ oc_melee
                    #   nearest_dist = mapl.get_nearest_coords([start_pos], oco_info.box, move_distance / 5)[0]
                    #   if 0 <= nearest_dist:
                    #       oc_melee = [p for p in oco_info.melee if mapl.distance(p, start_pos) * 5 <= move_distance]    

                    new_location, arrow = move_towards(monster_location, target_location, move_distance, occupied_positions)
                    #command_list.append(f"{pref}echo DISTANCEEEE: {new_location}")
                    update_monster_position(monster, new_location)
                    occupied_positions.add(new_location)
                    if arrow:
                        overlays.append(arrow)
                    monster_location = new_location
                    desc.append(f"{indexed_combatant} dashes {int(move_distance)} ft. towards {chosen_target}.")
                    map_state["combatants"] = out
                    map_url = mapl.generate_map_image(overlays)
                    command_list.append(f'{pref}embed -title "Monster Dashes: {monster.name}" -desc "{desc[-1]}" -image "{map_url}" -footer "{footer}"')
                    command_list.append(f'{pref}i n')
                    return
                else:
                    target_melee_positions = mapl.melee_box(monster_size_mod, target_pos, target_size_mod)
                    unoccupied_melee_positions = [pos for pos in target_melee_positions if pos not in occupied_positions]
                    if 0 < len(unoccupied_melee_positions):
                        target_melee_positions = unoccupied_melee_positions
                    melee_position = mapl.get_nearest_coords([start_pos], target_melee_positions)[2]
                    melee_location = mapl.coords_to_loc(melee_position)
                    new_location, arrow = melee_location, None
                    if 0 < len(unoccupied_melee_positions):
                        arrow = create_arrow_overlay(monster_location, melee_location)
                    else:
                        new_location, arrow = move_towards(monster_location, melee_location, move_distance, occupied_positions)
                    update_monster_position(monster, new_location)
                    occupied_positions.add(new_location)
                    if arrow:
                        overlays.append(arrow)
                    start_pos = mapl.loc_to_coords(monster_location)
                    end_pos = mapl.loc_to_coords(new_location)
                    moved_distance = mapl.distance(start_pos, end_pos) * 5
                    new_monster_box = mapl.box(end_pos, monster_size_mod)
                    distance = round(mapl.get_nearest_coords(new_monster_box, target_box)[0]) * 5
                    desc.append(f"{indexed_combatant} moves {int(moved_distance)} ft. towards {chosen_target}.")
            else:
                desc.append(f"{indexed_combatant} holds position to attack {chosen_target}.")

            # After movement, display the updated map
            map_state["combatants"] = out
            map_url = mapl.generate_map_image(overlays)
            command_list.append(f'{pref}embed -title "Monster Movement: {monster.name}" -desc "{desc[-1]}" -image "{map_url}" -footer "{footer}"')

        else:
            desc.append(f"Could not find location for target: {chosen_target}")

    else:
        chosen_target = targets[randint(len(targets))]
        distance = 8  # Assume adjacent if no map
        desc.append(f"{indexed_combatant} attacks {chosen_target}.")

    # Attack logic
    
    if distance <= get_max_attack_reach(monster.attacks) and (curr_hp > 0 or autolib.onDeath(indexed_combatant, c.combatants) == "relentless"):
        # Multiattack logic
        mon_actions = autolib.getActions(monster_name, autolib.buildDB())
        multi_atks = autolib.getMultiAttacks(mon_actions)

        if multi_atks:
            for atk, num in multi_atks.items():
                atkr = autolib.resolveVersatile(atk)
                command_list.append(f'{pref}i a "{atkr}" -rr {num} autoc -t {chosen_target} -phrase ":robot: _Triggered by auto monster AI_ :crossed_swords: Multiattack :crossed_swords:"')
            command_list.append(f'{pref}i n')
        else:
            chosen_atk_string = autolib.getAttack(indexed_combatant, c.combatants)
            command_list.append(f'{pref}i a "{chosen_atk_string}" -t {chosen_target} autoc -phrase ":robot: _Triggered by auto monster AI_"')
            command_list.append(f'{pref}i n')    
    elif curr_hp <= 0:
        on_death = autolib.onDeath(indexed_combatant, c.combatants)
        if on_death:
            target_string = f"-t {chosen_target}" if "death" in on_death else ""
            command_list.append(f'{pref}i a "{on_death}" {target_string} -phrase ":robot: _Triggered by auto monster AI_"')
        else:
            desc.append(f"Skipping dead monster: {indexed_combatant}")
            command_list.append(f'{pref}i n')
    else:
        desc.append(f"{indexed_combatant} couldn't reach {chosen_target} to attack.")
        command_list.append(f'{pref}i n')

    if monster.hp <= 0:
        remove_dead_monster(c, monster, out, desc)
        map_url = mapl.generate_map_image(overlays)
        command_list.append(f'{pref}embed -title "Skipping dead monster: {monster_name}" -desc "{monster_name} has been defeated and removed from the map. Its turn will be skipped." -image "{map_url}" -footer "{footer}"')
        return

def remove_dead_monster(combat, monster, out, desc):
    if monster.name in out:
        out.pop(monster.name)
    desc.append(f"{monster.name} has fallen and been removed from the map.")

def toggle_monster_color(monster, new_color):
    note_dict = mapl.parse_note(monster.note)
    original_color = note_dict.get('color', 'r')
    note_dict['color'] = new_color
    new_note = ' | '.join(f"{k.title()}: {v}" for k, v in note_dict.items())
    monster.set_note(new_note)
    
    if monster.name in out:
        out[monster.name]['color'] = new_color
    
    return original_color


def process_map_absentee_monster_turn(indexed_combatant, command_list):
    title = f'New monster detected: {indexed_combatant}'
    desc_text = f'This monster is not currently on the map, please place the monster\'s token on the map manually using: ```{pref}map -t {indexed_combatant}|C4```\nReplace `C4` to any location you like.'
    command_list.append(f"""{pref}embed -title "{title}" -desc "{desc_text}" -footer '{footer}'""")
    command_list.append(f'{pref}i n')

# Initialize overlays and descriptions
overlays = []
desc = []


###### TEST SUITES ######




###### TEST SUITES ######

# Main code execution starts here

targets = [t.name for t in party_list if not autolib.isGhost(c, t)]
if not targets:
    err(f'No playable characters found within Combat Initiative to target!\n\nPlease join the combat initiative using `{pref}i join` or remove ghost effect from characters')


if c.current is None:
    title = f'Booting up ancient artificial intelligences! :robot:'
    if monster_names:
        desc_text = f'\n:robot: _Auto-attack sequence initiated!_\n\nAutomating the following monsters:\n**{", ".join(monster_names)}**\n\n**Use `{cmd}` again now to automate all monsters in combat!**'
        command_list.append(f'{pref}i n')
    else:
        desc_text = f'_No monsters found in initiative!_\n\nThat\'s fine, feel free to add them any time and run `{cmd}` every time it\'s the monster\'s turn!'
    command_list.append(f"""{pref}embed -title "{title}" -desc "{desc_text}" -footer '{footer}'""")
    return command + nl.join(command_list)
    
current_init = None if not c.current else c.current.name
if current_init in monster_names and not autolib.hasMonsterGroup(c):
    indexed_cname_list = []
    curr_combatant = c.current
    
    map_url = mapl.generate_map_image(overlays)
    command_list.append(f'''{pref}embed -title "Monsters are deciding their actions..." -image "{map_url}" -footer "{footer}"''')
    
    if inp == 'once':
        # Implement the 'once' sub-command
        if current_init in monster_names:
            process_monster_turn(current_init, targets, c, out, overlays, desc, command_list)
            # Update map_state["combatants"] with 'out'
            map_state["combatants"] = out
            if overlays:
                map_url = mapl.generate_map_image(overlays)
                map_embed = f'{pref}embed -title "Updated Map" -desc "Monster movements displayed" -image "{map_url}" -footer "{footer}"'
                command_list.append(map_embed)
            return command + nl.join(command_list)
        
    # Build the indexed list starting from current initiative
    # Sort the combatants by initiative (descending) and then by name
    combatants_in_order = c.combatants
    cname_list_sorted = [combatant.name for combatant in combatants_in_order]

    indexed_cname_list = cname_list_sorted[cname_list_sorted.index(current_init):] + cname_list_sorted[:cname_list_sorted.index(current_init)]

    if len(indexed_cname_list) > 4:
        indexed_cname_list = indexed_cname_list[:4]

    for indexed_combatant in indexed_cname_list:
        if len(command_list) > 12:
            title = f'Whoa! You\'re pushing the limits of Avrae right now!'
            desc_text = f'Unfortunately, this is the maximum number of attacks you can automate to prevent unnecessarily over-stressing Avrae!\n\n**But no worries, you can simply use `{cmd}` again now to repeat the cycle!**'
            while len(command_list) > 12:
                command_list.reverse()
                last_n = command_list.index(f'{pref}i n')
                command_list = command_list[last_n+1:]
                command_list.reverse()
            command_list.append(f'{pref}i n')
            command_list.append(f"""{pref}embed -title "{title}" -desc "{desc_text}" -footer '{footer}'""")
            command += nl.join(command_list)
            return command
        if indexed_combatant in monster_names:
            monster = c.get_combatant(indexed_combatant)    
            note = mapl.parse_note(monster.note)

            if not note or not 'location' in note:
                process_map_absentee_monster_turn(indexed_combatant, command_list)
            else:
                process_monster_turn(indexed_combatant, targets, c, out, overlays, desc, command_list)
                toggle_monster_color(monster, 'r')
        else:
            # Handle non-monster combatants
            if indexed_combatant.casefold() in ['map', 'dm', 'lair'] and c.get_combatant(indexed_combatant).init == 20:
                title = f'Automation Complete! Waiting on Lair Action :dragon:'
                desc_text = f'Use `{pref}i n` if there are no actions to take this round!'
            elif inp1.lower() in 'react':
                command_list.pop()
                title = f'Automation Complete! Pausing to allow player reaction! :mage:'
                desc_text = f'After taking any reaction use `{pref}i n`'
            else:
                title = f'Automation Complete! It\'s a player turn now! :mage:'
                desc_text = f'Waiting on **{indexed_combatant}** to play their turn!'
            command_list.append(f"""{pref}embed -title "{title}" -desc "{desc_text}" -footer '{footer}'""")
            break

    # Update map_state["combatants"] with 'out'
    map_state["combatants"] = out


    if overlays:
        map_url = mapl.generate_map_image(overlays)
        map_embed = f'{pref}embed -title "Monster Movement Summary" -desc "Monster movements so far:" -image "{map_url}" -footer "{footer}"'
        command_list.append(map_embed)

    command += nl.join(command_list)
    return command


# It's a player's turn
if current_init.casefold() in ['map', 'dm', 'lair'] and c.turn_num == 20:
    title = f'Waiting on Lair Action :dragon:'
    desc_text = f'Use `{pref}i n` if there are no actions to take this round!'
else:
    title = f'It\'s a player turn! :mage:'
    if not get_uvar('mapStates'):
        desc_text = f"""
Waiting on **{current_init}** to play their turn!

To move your player character on the map:

1. Ensure that you or the server you are in is subscribed to the `{pref}map` alias.
    - You can quickly add it as a personal alias using:
    ```{pref}alias subscribe https://avrae.io/dashboard/workshop/5f6a4623f4c89c324d6a5cd3```

2. Move your character using the `{pref}move` alias: (companion alias to `{pref}map`)
    - For example:
   ```{pref}move C4```
   (Replace "C4" with the cell address of your desired location on the map.)
"""
    else:
        desc_text = f"Waiting on **{current_init}** to play their turn!"

return f"""embed -title "{title}" -desc "{desc_text}" -footer "{footer}" """
</drac2>
